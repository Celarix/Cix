//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from D:\Documents\GitHub\Cix\antlrTest\Cix.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

namespace Celarix.Cix.Compiler.Parse.AST
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
    [System.CLSCompliant(false)]
    public partial class CixParser : Antlr4.Runtime.Parser
    {
        protected static DFA[] decisionToDFA;
        protected static PredictionContextCache sharedContextCache = new PredictionContextCache();

        public const int
            T__0 = 1,
            T__1 = 2,
            T__2 = 3,
            T__3 = 4,
            T__4 = 5,
            T__5 = 6,
            T__6 = 7,
            Whitespace = 8,
            Break = 9,
            Case = 10,
            Continue = 11,
            Default = 12,
            Do = 13,
            Double = 14,
            Else = 15,
            Float = 16,
            Global = 17,
            For = 18,
            If = 19,
            Int = 20,
            Long = 21,
            Return = 22,
            Short = 23,
            Sizeof = 24,
            Struct = 25,
            Void = 26,
            While = 27,
            LeftParen = 28,
            RightParen = 29,
            LeftBracket = 30,
            RightBracket = 31,
            OpenScope = 32,
            CloseScope = 33,
            LessThan = 34,
            LessThanOrEqualTo = 35,
            GreaterThan = 36,
            GreaterThanOrEqualTo = 37,
            ShiftLeft = 38,
            ShiftRight = 39,
            Plus = 40,
            Increment = 41,
            Minus = 42,
            Decrement = 43,
            Asterisk = 44,
            Divide = 45,
            Modulus = 46,
            Ampersand = 47,
            BitwiseOr = 48,
            LogicalAnd = 49,
            LogicalOr = 50,
            BitwiseXor = 51,
            LogicalNot = 52,
            BitwiseNot = 53,
            Question = 54,
            Colon = 55,
            Semicolon = 56,
            Comma = 57,
            Assign = 58,
            MultiplyAssign = 59,
            DivideAssign = 60,
            ModulusAssign = 61,
            AddAssign = 62,
            SubtractAssign = 63,
            ShiftLeftAssign = 64,
            ShiftRightAssign = 65,
            BitwiseAndAssign = 66,
            BitwiseXorAssign = 67,
            BitwiseOrAssign = 68,
            Equals = 69,
            NotEquals = 70,
            PointerMemberAccess = 71,
            DirectMemberAccess = 72,
            Integer = 73,
            FloatingPoint = 74,
            Digit = 75,
            StringLiteral = 76,
            Identifier = 77,
            IdentifierFirstChar = 78,
            IdentifierChar = 79,
            HexDigit = 80;

        public const int
            RULE_primaryExpression = 0,
            RULE_postfixExpression = 1,
            RULE_argumentExpressionList = 2,
            RULE_unaryExpression = 3,
            RULE_unaryOperator = 4,
            RULE_castExpression = 5,
            RULE_multiplicativeExpression = 6,
            RULE_additiveExpression = 7,
            RULE_shiftExpression = 8,
            RULE_relationalExpression = 9,
            RULE_equalityExpression = 10,
            RULE_andExpression = 11,
            RULE_exclusiveOrExpression = 12,
            RULE_inclusiveOrExpression = 13,
            RULE_logicalAndExpression = 14,
            RULE_logicalOrExpression = 15,
            RULE_conditionalExpression = 16,
            RULE_assignmentExpression = 17,
            RULE_assignmentOperator = 18,
            RULE_expression = 19,
            RULE_constantExpression = 20,
            RULE_typeName = 21,
            RULE_funcptrTypeName = 22,
            RULE_typeNameList = 23,
            RULE_primitiveType = 24,
            RULE_pointerAsteriskList = 25,
            RULE_variableDeclarationStatement = 26,
            RULE_variableDeclarationWithInitializationStatement = 27,
            RULE_struct = 28,
            RULE_structMember = 29,
            RULE_structArraySize = 30,
            RULE_globalVariableDeclaration = 31,
            RULE_function = 32,
            RULE_functionParameterList = 33,
            RULE_functionParameter = 34,
            RULE_statement = 35,
            RULE_block = 36,
            RULE_breakStatement = 37,
            RULE_conditionalStatement = 38,
            RULE_continueStatement = 39,
            RULE_elseStatement = 40,
            RULE_doWhileStatement = 41,
            RULE_expressionStatement = 42,
            RULE_forStatement = 43,
            RULE_returnStatement = 44,
            RULE_switchStatement = 45,
            RULE_caseStatement = 46,
            RULE_literalCaseStatement = 47,
            RULE_defaultCaseStatement = 48,
            RULE_whileStatement = 49,
            RULE_number = 50,
            RULE_sourceFile = 51;

        public static readonly string[] ruleNames =
        {
            "primaryExpression", "postfixExpression", "argumentExpressionList", "unaryExpression", "unaryOperator",
            "castExpression", "multiplicativeExpression", "additiveExpression", "shiftExpression",
            "relationalExpression", "equalityExpression", "andExpression", "exclusiveOrExpression",
            "inclusiveOrExpression", "logicalAndExpression", "logicalOrExpression", "conditionalExpression",
            "assignmentExpression", "assignmentOperator", "expression", "constantExpression", "typeName",
            "funcptrTypeName", "typeNameList", "primitiveType", "pointerAsteriskList",
            "variableDeclarationStatement", "variableDeclarationWithInitializationStatement", "struct",
            "structMember", "structArraySize", "globalVariableDeclaration", "function", "functionParameterList",
            "functionParameter", "statement", "block", "breakStatement", "conditionalStatement",
            "continueStatement", "elseStatement", "doWhileStatement", "expressionStatement", "forStatement",
            "returnStatement", "switchStatement", "caseStatement", "literalCaseStatement", "defaultCaseStatement",
            "whileStatement", "number", "sourceFile"
        };

        private static readonly string[] _LiteralNames =
        {
            null, "'@funcptr<'", "'byte'", "'sbyte'", "'ushort'",
            "'uint'", "'ulong'", "'switch'", null, "'break'",
            "'case'", "'continue'", "'default'", "'do'", "'double'",
            "'else'", "'float'", "'global'", "'for'", "'if'",
            "'int'", "'long'", "'return'", "'short'", "'sizeof'",
            "'struct'", "'void'", "'while'", "'('", "')'",
            "'['", "']'", "'{'", "'}'", "'<'",
            "'<='", "'>'", "'>='", "'<<'", "'>>'",
            "'+'", "'++'", "'-'", "'--'", "'*'",
            "'/'", "'%'", "'&'", "'|'", "'&&'",
            "'||'", "'^'", "'!'", "'~'", "'?'",
            "':'", "';'", "','", "'='", "'*='",
            "'/='", "'%='", "'+='", "'-='", "'<<='",
            "'>>='", "'&='", "'^='", "'|='", "'=='",
            "'!='", "'->'", "'.'"
        };

        private static readonly string[] _SymbolicNames =
        {
            null, null, null, null, null,
            null, null, null, "Whitespace", "Break",
            "Case", "Continue", "Default", "Do", "Double",
            "Else", "Float", "Global", "For", "If",
            "Int", "Long", "Return", "Short", "Sizeof",
            "Struct", "Void", "While", "LeftParen", "RightParen",
            "LeftBracket", "RightBracket", "OpenScope", "CloseScope", "LessThan",
            "LessThanOrEqualTo", "GreaterThan", "GreaterThanOrEqualTo", "ShiftLeft", "ShiftRight",
            "Plus", "Increment", "Minus", "Decrement", "Asterisk",
            "Divide", "Modulus", "Ampersand", "BitwiseOr", "LogicalAnd",
            "LogicalOr", "BitwiseXor", "LogicalNot", "BitwiseNot", "Question",
            "Colon", "Semicolon", "Comma", "Assign", "MultiplyAssign",
            "DivideAssign", "ModulusAssign", "AddAssign", "SubtractAssign", "ShiftLeftAssign",
            "ShiftRightAssign", "BitwiseAndAssign", "BitwiseXorAssign", "BitwiseOrAssign", "Equals",
            "NotEquals", "PointerMemberAccess", "DirectMemberAccess", "Integer", "FloatingPoint",
            "Digit", "StringLiteral", "Identifier", "IdentifierFirstChar", "IdentifierChar",
            "HexDigit"
        };

        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [NotNull]
        public override IVocabulary Vocabulary
        {
            get { return DefaultVocabulary; }
        }

        public override string GrammarFileName
        {
            get { return "Cix.g4"; }
        }

        public override string[] RuleNames
        {
            get { return ruleNames; }
        }

        public override string SerializedAtn
        {
            get { return new string(_serializedATN); }
        }

        static CixParser()
        {
            decisionToDFA = new DFA[_ATN.NumberOfDecisions];

            for (int i = 0; i < _ATN.NumberOfDecisions; i++)
            {
                decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
            }
        }

        public CixParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

        public CixParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
            : base(input, output, errorOutput)
        {
            Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
        }

        public partial class PrimaryExpressionContext : ParserRuleContext
        {
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode StringLiteral() { return GetToken(CixParser.StringLiteral, 0); }
            public NumberContext number() { return GetRuleContext<NumberContext>(0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }

            public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_primaryExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterPrimaryExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitPrimaryExpression(this);
            }
        }

        [RuleVersion(0)]
        public PrimaryExpressionContext primaryExpression()
        {
            PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, State);
            EnterRule(_localctx, 0, RULE_primaryExpression);

            try
            {
                State = 111;
                ErrorHandler.Sync(this);

                switch (TokenStream.LA(1))
                {
                    case Identifier:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 104;
                        Match(Identifier);
                    }

                        break;
                    case StringLiteral:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 105;
                        Match(StringLiteral);
                    }

                        break;
                    case Integer:
                    case FloatingPoint:
                        EnterOuterAlt(_localctx, 3);

                    {
                        State = 106;
                        number();
                    }

                        break;
                    case LeftParen:
                        EnterOuterAlt(_localctx, 4);

                    {
                        State = 107;
                        Match(LeftParen);
                        State = 108;
                        expression();
                        State = 109;
                        Match(RightParen);
                    }

                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class PostfixExpressionContext : ParserRuleContext
        {
            public PrimaryExpressionContext primaryExpression() { return GetRuleContext<PrimaryExpressionContext>(0); }
            public PostfixExpressionContext postfixExpression() { return GetRuleContext<PostfixExpressionContext>(0); }
            public ITerminalNode LeftBracket() { return GetToken(CixParser.LeftBracket, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightBracket() { return GetToken(CixParser.RightBracket, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }

            public ArgumentExpressionListContext argumentExpressionList()
            {
                return GetRuleContext<ArgumentExpressionListContext>(0);
            }

            public ITerminalNode DirectMemberAccess() { return GetToken(CixParser.DirectMemberAccess, 0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode PointerMemberAccess() { return GetToken(CixParser.PointerMemberAccess, 0); }
            public ITerminalNode Increment() { return GetToken(CixParser.Increment, 0); }
            public ITerminalNode Decrement() { return GetToken(CixParser.Decrement, 0); }

            public PostfixExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_postfixExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterPostfixExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitPostfixExpression(this);
            }
        }

        [RuleVersion(0)]
        public PostfixExpressionContext postfixExpression() { return postfixExpression(0); }

        private PostfixExpressionContext postfixExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            PostfixExpressionContext _localctx = new PostfixExpressionContext(Context, _parentState);
            PostfixExpressionContext _prevctx = _localctx;
            int _startState = 2;
            EnterRecursionRule(_localctx, 2, RULE_postfixExpression, _p);
            int _la;

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 114;
                        primaryExpression();
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 139;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 3, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 137;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 2, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 116;

                                        if (!(Precpred(Context, 6)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 6)");
                                        State = 117;
                                        Match(LeftBracket);
                                        State = 118;
                                        expression();
                                        State = 119;
                                        Match(RightBracket);
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 121;

                                        if (!(Precpred(Context, 5)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 5)");
                                        State = 122;
                                        Match(LeftParen);
                                        State = 124;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);

                                        if (((((_la - 24)) & ~0x3f) == 0
                                            && ((1L << (_la - 24))
                                                & ((1L << (Sizeof - 24))
                                                    | (1L << (LeftParen - 24))
                                                    | (1L << (Plus - 24))
                                                    | (1L << (Increment - 24))
                                                    | (1L << (Minus - 24))
                                                    | (1L << (Decrement - 24))
                                                    | (1L << (Asterisk - 24))
                                                    | (1L << (Ampersand - 24))
                                                    | (1L << (LogicalNot - 24))
                                                    | (1L << (BitwiseNot - 24))
                                                    | (1L << (Integer - 24))
                                                    | (1L << (FloatingPoint - 24))
                                                    | (1L << (StringLiteral - 24))
                                                    | (1L << (Identifier - 24))))
                                            != 0))
                                        {
                                            {
                                                State = 123;
                                                argumentExpressionList(0);
                                            }
                                        }

                                        State = 126;
                                        Match(RightParen);
                                    }

                                        break;
                                    case 3:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 127;

                                        if (!(Precpred(Context, 4)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 4)");
                                        State = 128;
                                        Match(DirectMemberAccess);
                                        State = 129;
                                        Match(Identifier);
                                    }

                                        break;
                                    case 4:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 130;

                                        if (!(Precpred(Context, 3)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 131;
                                        Match(PointerMemberAccess);
                                        State = 132;
                                        Match(Identifier);
                                    }

                                        break;
                                    case 5:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 133;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 134;
                                        Match(Increment);
                                    }

                                        break;
                                    case 6:
                                    {
                                        _localctx = new PostfixExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
                                        State = 135;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 136;
                                        Match(Decrement);
                                    }

                                        break;
                                }
                            }
                        }

                        State = 141;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 3, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class ArgumentExpressionListContext : ParserRuleContext
        {
            public AssignmentExpressionContext assignmentExpression()
            {
                return GetRuleContext<AssignmentExpressionContext>(0);
            }

            public ArgumentExpressionListContext argumentExpressionList()
            {
                return GetRuleContext<ArgumentExpressionListContext>(0);
            }

            public ITerminalNode Comma() { return GetToken(CixParser.Comma, 0); }

            public ArgumentExpressionListContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_argumentExpressionList; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterArgumentExpressionList(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitArgumentExpressionList(this);
            }
        }

        [RuleVersion(0)]
        public ArgumentExpressionListContext argumentExpressionList() { return argumentExpressionList(0); }

        private ArgumentExpressionListContext argumentExpressionList(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            ArgumentExpressionListContext _localctx = new ArgumentExpressionListContext(Context, _parentState);
            ArgumentExpressionListContext _prevctx = _localctx;
            int _startState = 4;
            EnterRecursionRule(_localctx, 4, RULE_argumentExpressionList, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 143;
                        assignmentExpression();
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 150;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 4, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new ArgumentExpressionListContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_argumentExpressionList);
                                    State = 145;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 146;
                                    Match(Comma);
                                    State = 147;
                                    assignmentExpression();
                                }
                            }
                        }

                        State = 152;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 4, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class UnaryExpressionContext : ParserRuleContext
        {
            public PostfixExpressionContext postfixExpression() { return GetRuleContext<PostfixExpressionContext>(0); }
            public ITerminalNode Increment() { return GetToken(CixParser.Increment, 0); }
            public UnaryExpressionContext unaryExpression() { return GetRuleContext<UnaryExpressionContext>(0); }
            public ITerminalNode Decrement() { return GetToken(CixParser.Decrement, 0); }
            public UnaryOperatorContext unaryOperator() { return GetRuleContext<UnaryOperatorContext>(0); }
            public CastExpressionContext castExpression() { return GetRuleContext<CastExpressionContext>(0); }
            public ITerminalNode Sizeof() { return GetToken(CixParser.Sizeof, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }

            public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_unaryExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterUnaryExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitUnaryExpression(this);
            }
        }

        [RuleVersion(0)]
        public UnaryExpressionContext unaryExpression()
        {
            UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
            EnterRule(_localctx, 6, RULE_unaryExpression);

            try
            {
                State = 168;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 5, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 153;
                        postfixExpression(0);
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 154;
                        Match(Increment);
                        State = 155;
                        unaryExpression();
                    }

                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);

                    {
                        State = 156;
                        Match(Decrement);
                        State = 157;
                        unaryExpression();
                    }

                        break;
                    case 4:
                        EnterOuterAlt(_localctx, 4);

                    {
                        State = 158;
                        unaryOperator();
                        State = 159;
                        castExpression();
                    }

                        break;
                    case 5:
                        EnterOuterAlt(_localctx, 5);

                    {
                        State = 161;
                        Match(Sizeof);
                        State = 162;
                        unaryExpression();
                    }

                        break;
                    case 6:
                        EnterOuterAlt(_localctx, 6);

                    {
                        State = 163;
                        Match(Sizeof);
                        State = 164;
                        Match(LeftParen);
                        State = 165;
                        typeName();
                        State = 166;
                        Match(RightParen);
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class UnaryOperatorContext : ParserRuleContext
        {
            public ITerminalNode Ampersand() { return GetToken(CixParser.Ampersand, 0); }
            public ITerminalNode Asterisk() { return GetToken(CixParser.Asterisk, 0); }
            public ITerminalNode Plus() { return GetToken(CixParser.Plus, 0); }
            public ITerminalNode Minus() { return GetToken(CixParser.Minus, 0); }
            public ITerminalNode BitwiseNot() { return GetToken(CixParser.BitwiseNot, 0); }
            public ITerminalNode LogicalNot() { return GetToken(CixParser.LogicalNot, 0); }

            public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_unaryOperator; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterUnaryOperator(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitUnaryOperator(this);
            }
        }

        [RuleVersion(0)]
        public UnaryOperatorContext unaryOperator()
        {
            UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
            EnterRule(_localctx, 8, RULE_unaryOperator);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 170;
                    _la = TokenStream.LA(1);

                    if (!((((_la) & ~0x3f) == 0
                        && ((1L << _la)
                            & ((1L << Plus)
                                | (1L << Minus)
                                | (1L << Asterisk)
                                | (1L << Ampersand)
                                | (1L << LogicalNot)
                                | (1L << BitwiseNot)))
                        != 0))) { ErrorHandler.RecoverInline(this); }
                    else
                    {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class CastExpressionContext : ParserRuleContext
        {
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public CastExpressionContext castExpression() { return GetRuleContext<CastExpressionContext>(0); }
            public UnaryExpressionContext unaryExpression() { return GetRuleContext<UnaryExpressionContext>(0); }

            public CastExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_castExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterCastExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitCastExpression(this);
            }
        }

        [RuleVersion(0)]
        public CastExpressionContext castExpression()
        {
            CastExpressionContext _localctx = new CastExpressionContext(Context, State);
            EnterRule(_localctx, 10, RULE_castExpression);

            try
            {
                State = 178;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 6, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 172;
                        Match(LeftParen);
                        State = 173;
                        typeName();
                        State = 174;
                        Match(RightParen);
                        State = 175;
                        castExpression();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 177;
                        unaryExpression();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class MultiplicativeExpressionContext : ParserRuleContext
        {
            public CastExpressionContext castExpression() { return GetRuleContext<CastExpressionContext>(0); }

            public MultiplicativeExpressionContext multiplicativeExpression()
            {
                return GetRuleContext<MultiplicativeExpressionContext>(0);
            }

            public ITerminalNode Asterisk() { return GetToken(CixParser.Asterisk, 0); }
            public ITerminalNode Divide() { return GetToken(CixParser.Divide, 0); }
            public ITerminalNode Modulus() { return GetToken(CixParser.Modulus, 0); }

            public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_multiplicativeExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
            }
        }

        [RuleVersion(0)]
        public MultiplicativeExpressionContext multiplicativeExpression() { return multiplicativeExpression(0); }

        private MultiplicativeExpressionContext multiplicativeExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, _parentState);
            MultiplicativeExpressionContext _prevctx = _localctx;
            int _startState = 12;
            EnterRecursionRule(_localctx, 12, RULE_multiplicativeExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 181;
                        castExpression();
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 194;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 8, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 192;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 7, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
                                        State = 183;

                                        if (!(Precpred(Context, 3)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 184;
                                        Match(Asterisk);
                                        State = 185;
                                        castExpression();
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
                                        State = 186;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 187;
                                        Match(Divide);
                                        State = 188;
                                        castExpression();
                                    }

                                        break;
                                    case 3:
                                    {
                                        _localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
                                        State = 189;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 190;
                                        Match(Modulus);
                                        State = 191;
                                        castExpression();
                                    }

                                        break;
                                }
                            }
                        }

                        State = 196;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 8, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class AdditiveExpressionContext : ParserRuleContext
        {
            public MultiplicativeExpressionContext multiplicativeExpression()
            {
                return GetRuleContext<MultiplicativeExpressionContext>(0);
            }

            public AdditiveExpressionContext additiveExpression()
            {
                return GetRuleContext<AdditiveExpressionContext>(0);
            }

            public ITerminalNode Plus() { return GetToken(CixParser.Plus, 0); }
            public ITerminalNode Minus() { return GetToken(CixParser.Minus, 0); }

            public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_additiveExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterAdditiveExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitAdditiveExpression(this);
            }
        }

        [RuleVersion(0)]
        public AdditiveExpressionContext additiveExpression() { return additiveExpression(0); }

        private AdditiveExpressionContext additiveExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, _parentState);
            AdditiveExpressionContext _prevctx = _localctx;
            int _startState = 14;
            EnterRecursionRule(_localctx, 14, RULE_additiveExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 198;
                        multiplicativeExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 208;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 10, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 206;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 9, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new AdditiveExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
                                        State = 200;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 201;
                                        Match(Plus);
                                        State = 202;
                                        multiplicativeExpression(0);
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new AdditiveExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
                                        State = 203;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 204;
                                        Match(Minus);
                                        State = 205;
                                        multiplicativeExpression(0);
                                    }

                                        break;
                                }
                            }
                        }

                        State = 210;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 10, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class ShiftExpressionContext : ParserRuleContext
        {
            public AdditiveExpressionContext additiveExpression()
            {
                return GetRuleContext<AdditiveExpressionContext>(0);
            }

            public ShiftExpressionContext shiftExpression() { return GetRuleContext<ShiftExpressionContext>(0); }
            public ITerminalNode ShiftLeft() { return GetToken(CixParser.ShiftLeft, 0); }
            public ITerminalNode ShiftRight() { return GetToken(CixParser.ShiftRight, 0); }

            public ShiftExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_shiftExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterShiftExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitShiftExpression(this);
            }
        }

        [RuleVersion(0)]
        public ShiftExpressionContext shiftExpression() { return shiftExpression(0); }

        private ShiftExpressionContext shiftExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            ShiftExpressionContext _localctx = new ShiftExpressionContext(Context, _parentState);
            ShiftExpressionContext _prevctx = _localctx;
            int _startState = 16;
            EnterRecursionRule(_localctx, 16, RULE_shiftExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 212;
                        additiveExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 222;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 12, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 220;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 11, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new ShiftExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_shiftExpression);
                                        State = 214;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 215;
                                        Match(ShiftLeft);
                                        State = 216;
                                        additiveExpression(0);
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new ShiftExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_shiftExpression);
                                        State = 217;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 218;
                                        Match(ShiftRight);
                                        State = 219;
                                        additiveExpression(0);
                                    }

                                        break;
                                }
                            }
                        }

                        State = 224;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 12, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class RelationalExpressionContext : ParserRuleContext
        {
            public ShiftExpressionContext shiftExpression() { return GetRuleContext<ShiftExpressionContext>(0); }

            public RelationalExpressionContext relationalExpression()
            {
                return GetRuleContext<RelationalExpressionContext>(0);
            }

            public ITerminalNode LessThan() { return GetToken(CixParser.LessThan, 0); }
            public ITerminalNode GreaterThan() { return GetToken(CixParser.GreaterThan, 0); }
            public ITerminalNode LessThanOrEqualTo() { return GetToken(CixParser.LessThanOrEqualTo, 0); }
            public ITerminalNode GreaterThanOrEqualTo() { return GetToken(CixParser.GreaterThanOrEqualTo, 0); }

            public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_relationalExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterRelationalExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitRelationalExpression(this);
            }
        }

        [RuleVersion(0)]
        public RelationalExpressionContext relationalExpression() { return relationalExpression(0); }

        private RelationalExpressionContext relationalExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, _parentState);
            RelationalExpressionContext _prevctx = _localctx;
            int _startState = 18;
            EnterRecursionRule(_localctx, 18, RULE_relationalExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 226;
                        shiftExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 242;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 14, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 240;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 13, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new RelationalExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 228;

                                        if (!(Precpred(Context, 4)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 4)");
                                        State = 229;
                                        Match(LessThan);
                                        State = 230;
                                        shiftExpression(0);
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new RelationalExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 231;

                                        if (!(Precpred(Context, 3)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 232;
                                        Match(GreaterThan);
                                        State = 233;
                                        shiftExpression(0);
                                    }

                                        break;
                                    case 3:
                                    {
                                        _localctx = new RelationalExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 234;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 235;
                                        Match(LessThanOrEqualTo);
                                        State = 236;
                                        shiftExpression(0);
                                    }

                                        break;
                                    case 4:
                                    {
                                        _localctx = new RelationalExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 237;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 238;
                                        Match(GreaterThanOrEqualTo);
                                        State = 239;
                                        shiftExpression(0);
                                    }

                                        break;
                                }
                            }
                        }

                        State = 244;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 14, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class EqualityExpressionContext : ParserRuleContext
        {
            public RelationalExpressionContext relationalExpression()
            {
                return GetRuleContext<RelationalExpressionContext>(0);
            }

            public EqualityExpressionContext equalityExpression()
            {
                return GetRuleContext<EqualityExpressionContext>(0);
            }

            public ITerminalNode Equals() { return GetToken(CixParser.Equals, 0); }
            public ITerminalNode NotEquals() { return GetToken(CixParser.NotEquals, 0); }

            public EqualityExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_equalityExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterEqualityExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitEqualityExpression(this);
            }
        }

        [RuleVersion(0)]
        public EqualityExpressionContext equalityExpression() { return equalityExpression(0); }

        private EqualityExpressionContext equalityExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            EqualityExpressionContext _localctx = new EqualityExpressionContext(Context, _parentState);
            EqualityExpressionContext _prevctx = _localctx;
            int _startState = 20;
            EnterRecursionRule(_localctx, 20, RULE_equalityExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 246;
                        relationalExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 256;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 16, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                State = 254;
                                ErrorHandler.Sync(this);

                                switch (Interpreter.AdaptivePredict(TokenStream, 15, Context))
                                {
                                    case 1:
                                    {
                                        _localctx = new EqualityExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
                                        State = 248;

                                        if (!(Precpred(Context, 2)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 249;
                                        Match(Equals);
                                        State = 250;
                                        relationalExpression(0);
                                    }

                                        break;
                                    case 2:
                                    {
                                        _localctx = new EqualityExpressionContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
                                        State = 251;

                                        if (!(Precpred(Context, 1)))
                                            throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                        State = 252;
                                        Match(NotEquals);
                                        State = 253;
                                        relationalExpression(0);
                                    }

                                        break;
                                }
                            }
                        }

                        State = 258;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 16, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class AndExpressionContext : ParserRuleContext
        {
            public EqualityExpressionContext equalityExpression()
            {
                return GetRuleContext<EqualityExpressionContext>(0);
            }

            public AndExpressionContext andExpression() { return GetRuleContext<AndExpressionContext>(0); }
            public ITerminalNode Ampersand() { return GetToken(CixParser.Ampersand, 0); }

            public AndExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_andExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterAndExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitAndExpression(this);
            }
        }

        [RuleVersion(0)]
        public AndExpressionContext andExpression() { return andExpression(0); }

        private AndExpressionContext andExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            AndExpressionContext _localctx = new AndExpressionContext(Context, _parentState);
            AndExpressionContext _prevctx = _localctx;
            int _startState = 22;
            EnterRecursionRule(_localctx, 22, RULE_andExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 260;
                        equalityExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 267;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 17, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new AndExpressionContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_andExpression);
                                    State = 262;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 263;
                                    Match(Ampersand);
                                    State = 264;
                                    equalityExpression(0);
                                }
                            }
                        }

                        State = 269;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 17, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class ExclusiveOrExpressionContext : ParserRuleContext
        {
            public AndExpressionContext andExpression() { return GetRuleContext<AndExpressionContext>(0); }

            public ExclusiveOrExpressionContext exclusiveOrExpression()
            {
                return GetRuleContext<ExclusiveOrExpressionContext>(0);
            }

            public ITerminalNode BitwiseXor() { return GetToken(CixParser.BitwiseXor, 0); }

            public ExclusiveOrExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_exclusiveOrExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterExclusiveOrExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitExclusiveOrExpression(this);
            }
        }

        [RuleVersion(0)]
        public ExclusiveOrExpressionContext exclusiveOrExpression() { return exclusiveOrExpression(0); }

        private ExclusiveOrExpressionContext exclusiveOrExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            ExclusiveOrExpressionContext _localctx = new ExclusiveOrExpressionContext(Context, _parentState);
            ExclusiveOrExpressionContext _prevctx = _localctx;
            int _startState = 24;
            EnterRecursionRule(_localctx, 24, RULE_exclusiveOrExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 271;
                        andExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 278;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 18, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new ExclusiveOrExpressionContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_exclusiveOrExpression);
                                    State = 273;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 274;
                                    Match(BitwiseXor);
                                    State = 275;
                                    andExpression(0);
                                }
                            }
                        }

                        State = 280;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 18, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class InclusiveOrExpressionContext : ParserRuleContext
        {
            public ExclusiveOrExpressionContext exclusiveOrExpression()
            {
                return GetRuleContext<ExclusiveOrExpressionContext>(0);
            }

            public InclusiveOrExpressionContext inclusiveOrExpression()
            {
                return GetRuleContext<InclusiveOrExpressionContext>(0);
            }

            public ITerminalNode BitwiseOr() { return GetToken(CixParser.BitwiseOr, 0); }

            public InclusiveOrExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_inclusiveOrExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterInclusiveOrExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitInclusiveOrExpression(this);
            }
        }

        [RuleVersion(0)]
        public InclusiveOrExpressionContext inclusiveOrExpression() { return inclusiveOrExpression(0); }

        private InclusiveOrExpressionContext inclusiveOrExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            InclusiveOrExpressionContext _localctx = new InclusiveOrExpressionContext(Context, _parentState);
            InclusiveOrExpressionContext _prevctx = _localctx;
            int _startState = 26;
            EnterRecursionRule(_localctx, 26, RULE_inclusiveOrExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 282;
                        exclusiveOrExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 289;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 19, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new InclusiveOrExpressionContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_inclusiveOrExpression);
                                    State = 284;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 285;
                                    Match(BitwiseOr);
                                    State = 286;
                                    exclusiveOrExpression(0);
                                }
                            }
                        }

                        State = 291;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 19, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class LogicalAndExpressionContext : ParserRuleContext
        {
            public InclusiveOrExpressionContext inclusiveOrExpression()
            {
                return GetRuleContext<InclusiveOrExpressionContext>(0);
            }

            public LogicalAndExpressionContext logicalAndExpression()
            {
                return GetRuleContext<LogicalAndExpressionContext>(0);
            }

            public ITerminalNode LogicalAnd() { return GetToken(CixParser.LogicalAnd, 0); }

            public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_logicalAndExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterLogicalAndExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitLogicalAndExpression(this);
            }
        }

        [RuleVersion(0)]
        public LogicalAndExpressionContext logicalAndExpression() { return logicalAndExpression(0); }

        private LogicalAndExpressionContext logicalAndExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(Context, _parentState);
            LogicalAndExpressionContext _prevctx = _localctx;
            int _startState = 28;
            EnterRecursionRule(_localctx, 28, RULE_logicalAndExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 293;
                        inclusiveOrExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 300;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 20, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new LogicalAndExpressionContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_logicalAndExpression);
                                    State = 295;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 296;
                                    Match(LogicalAnd);
                                    State = 297;
                                    inclusiveOrExpression(0);
                                }
                            }
                        }

                        State = 302;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 20, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class LogicalOrExpressionContext : ParserRuleContext
        {
            public LogicalAndExpressionContext logicalAndExpression()
            {
                return GetRuleContext<LogicalAndExpressionContext>(0);
            }

            public LogicalOrExpressionContext logicalOrExpression()
            {
                return GetRuleContext<LogicalOrExpressionContext>(0);
            }

            public ITerminalNode LogicalOr() { return GetToken(CixParser.LogicalOr, 0); }

            public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_logicalOrExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterLogicalOrExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitLogicalOrExpression(this);
            }
        }

        [RuleVersion(0)]
        public LogicalOrExpressionContext logicalOrExpression() { return logicalOrExpression(0); }

        private LogicalOrExpressionContext logicalOrExpression(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(Context, _parentState);
            LogicalOrExpressionContext _prevctx = _localctx;
            int _startState = 30;
            EnterRecursionRule(_localctx, 30, RULE_logicalOrExpression, _p);

            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);

                {
                    {
                        State = 304;
                        logicalAndExpression(0);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 311;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 21, Context);

                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                    {
                        if (_alt == 1)
                        {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;

                            {
                                {
                                    _localctx = new LogicalOrExpressionContext(_parentctx, _parentState);
                                    PushNewRecursionContext(_localctx, _startState, RULE_logicalOrExpression);
                                    State = 306;

                                    if (!(Precpred(Context, 1)))
                                        throw new FailedPredicateException(this, "Precpred(Context, 1)");
                                    State = 307;
                                    Match(LogicalOr);
                                    State = 308;
                                    logicalAndExpression(0);
                                }
                            }
                        }

                        State = 313;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 21, Context);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { UnrollRecursionContexts(_parentctx); }

            return _localctx;
        }

        public partial class ConditionalExpressionContext : ParserRuleContext
        {
            public LogicalOrExpressionContext logicalOrExpression()
            {
                return GetRuleContext<LogicalOrExpressionContext>(0);
            }

            public ITerminalNode Question() { return GetToken(CixParser.Question, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode Colon() { return GetToken(CixParser.Colon, 0); }

            public ConditionalExpressionContext conditionalExpression()
            {
                return GetRuleContext<ConditionalExpressionContext>(0);
            }

            public ConditionalExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_conditionalExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterConditionalExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitConditionalExpression(this);
            }
        }

        [RuleVersion(0)]
        public ConditionalExpressionContext conditionalExpression()
        {
            ConditionalExpressionContext _localctx = new ConditionalExpressionContext(Context, State);
            EnterRule(_localctx, 32, RULE_conditionalExpression);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 314;
                    logicalOrExpression(0);
                    State = 320;
                    ErrorHandler.Sync(this);

                    switch (Interpreter.AdaptivePredict(TokenStream, 22, Context))
                    {
                        case 1:
                        {
                            State = 315;
                            Match(Question);
                            State = 316;
                            expression();
                            State = 317;
                            Match(Colon);
                            State = 318;
                            conditionalExpression();
                        }

                            break;
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class AssignmentExpressionContext : ParserRuleContext
        {
            public ConditionalExpressionContext conditionalExpression()
            {
                return GetRuleContext<ConditionalExpressionContext>(0);
            }

            public UnaryExpressionContext unaryExpression() { return GetRuleContext<UnaryExpressionContext>(0); }

            public AssignmentOperatorContext assignmentOperator()
            {
                return GetRuleContext<AssignmentOperatorContext>(0);
            }

            public AssignmentExpressionContext assignmentExpression()
            {
                return GetRuleContext<AssignmentExpressionContext>(0);
            }

            public AssignmentExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_assignmentExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterAssignmentExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitAssignmentExpression(this);
            }
        }

        [RuleVersion(0)]
        public AssignmentExpressionContext assignmentExpression()
        {
            AssignmentExpressionContext _localctx = new AssignmentExpressionContext(Context, State);
            EnterRule(_localctx, 34, RULE_assignmentExpression);

            try
            {
                State = 327;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 23, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 322;
                        conditionalExpression();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 323;
                        unaryExpression();
                        State = 324;
                        assignmentOperator();
                        State = 325;
                        assignmentExpression();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class AssignmentOperatorContext : ParserRuleContext
        {
            public ITerminalNode Assign() { return GetToken(CixParser.Assign, 0); }
            public ITerminalNode MultiplyAssign() { return GetToken(CixParser.MultiplyAssign, 0); }
            public ITerminalNode DivideAssign() { return GetToken(CixParser.DivideAssign, 0); }
            public ITerminalNode ModulusAssign() { return GetToken(CixParser.ModulusAssign, 0); }
            public ITerminalNode AddAssign() { return GetToken(CixParser.AddAssign, 0); }
            public ITerminalNode SubtractAssign() { return GetToken(CixParser.SubtractAssign, 0); }
            public ITerminalNode ShiftLeftAssign() { return GetToken(CixParser.ShiftLeftAssign, 0); }
            public ITerminalNode ShiftRightAssign() { return GetToken(CixParser.ShiftRightAssign, 0); }
            public ITerminalNode BitwiseAndAssign() { return GetToken(CixParser.BitwiseAndAssign, 0); }
            public ITerminalNode BitwiseXorAssign() { return GetToken(CixParser.BitwiseXorAssign, 0); }
            public ITerminalNode BitwiseOrAssign() { return GetToken(CixParser.BitwiseOrAssign, 0); }

            public AssignmentOperatorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_assignmentOperator; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterAssignmentOperator(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitAssignmentOperator(this);
            }
        }

        [RuleVersion(0)]
        public AssignmentOperatorContext assignmentOperator()
        {
            AssignmentOperatorContext _localctx = new AssignmentOperatorContext(Context, State);
            EnterRule(_localctx, 36, RULE_assignmentOperator);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 329;
                    _la = TokenStream.LA(1);

                    if (!(((((_la - 58)) & ~0x3f) == 0
                        && ((1L << (_la - 58))
                            & ((1L << (Assign - 58))
                                | (1L << (MultiplyAssign - 58))
                                | (1L << (DivideAssign - 58))
                                | (1L << (ModulusAssign - 58))
                                | (1L << (AddAssign - 58))
                                | (1L << (SubtractAssign - 58))
                                | (1L << (ShiftLeftAssign - 58))
                                | (1L << (ShiftRightAssign - 58))
                                | (1L << (BitwiseAndAssign - 58))
                                | (1L << (BitwiseXorAssign - 58))
                                | (1L << (BitwiseOrAssign - 58))))
                        != 0))) { ErrorHandler.RecoverInline(this); }
                    else
                    {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ExpressionContext : ParserRuleContext
        {
            public AssignmentExpressionContext assignmentExpression()
            {
                return GetRuleContext<AssignmentExpressionContext>(0);
            }

            public ExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_expression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitExpression(this);
            }
        }

        [RuleVersion(0)]
        public ExpressionContext expression()
        {
            ExpressionContext _localctx = new ExpressionContext(Context, State);
            EnterRule(_localctx, 38, RULE_expression);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 331;
                    assignmentExpression();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ConstantExpressionContext : ParserRuleContext
        {
            public ConditionalExpressionContext conditionalExpression()
            {
                return GetRuleContext<ConditionalExpressionContext>(0);
            }

            public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_constantExpression; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterConstantExpression(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitConstantExpression(this);
            }
        }

        [RuleVersion(0)]
        public ConstantExpressionContext constantExpression()
        {
            ConstantExpressionContext _localctx = new ConstantExpressionContext(Context, State);
            EnterRule(_localctx, 40, RULE_constantExpression);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 333;
                    conditionalExpression();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class TypeNameContext : ParserRuleContext
        {
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }

            public PointerAsteriskListContext pointerAsteriskList()
            {
                return GetRuleContext<PointerAsteriskListContext>(0);
            }

            public FuncptrTypeNameContext funcptrTypeName() { return GetRuleContext<FuncptrTypeNameContext>(0); }
            public PrimitiveTypeContext primitiveType() { return GetRuleContext<PrimitiveTypeContext>(0); }

            public TypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_typeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitTypeName(this);
            }
        }

        [RuleVersion(0)]
        public TypeNameContext typeName()
        {
            TypeNameContext _localctx = new TypeNameContext(Context, State);
            EnterRule(_localctx, 42, RULE_typeName);
            int _la;

            try
            {
                State = 347;
                ErrorHandler.Sync(this);

                switch (TokenStream.LA(1))
                {
                    case Identifier:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 335;
                        Match(Identifier);
                        State = 337;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);

                        if (_la == Asterisk)
                        {
                            {
                                State = 336;
                                pointerAsteriskList();
                            }
                        }

                    }

                        break;
                    case T__0:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 339;
                        funcptrTypeName();
                        State = 341;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);

                        if (_la == Asterisk)
                        {
                            {
                                State = 340;
                                pointerAsteriskList();
                            }
                        }

                    }

                        break;
                    case T__1:
                    case T__2:
                    case T__3:
                    case T__4:
                    case T__5:
                    case Double:
                    case Float:
                    case Int:
                    case Long:
                    case Short:
                    case Void:
                        EnterOuterAlt(_localctx, 3);

                    {
                        State = 343;
                        primitiveType();
                        State = 345;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);

                        if (_la == Asterisk)
                        {
                            {
                                State = 344;
                                pointerAsteriskList();
                            }
                        }

                    }

                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class FuncptrTypeNameContext : ParserRuleContext
        {
            public TypeNameListContext typeNameList() { return GetRuleContext<TypeNameListContext>(0); }
            public ITerminalNode GreaterThan() { return GetToken(CixParser.GreaterThan, 0); }

            public FuncptrTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_funcptrTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterFuncptrTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitFuncptrTypeName(this);
            }
        }

        [RuleVersion(0)]
        public FuncptrTypeNameContext funcptrTypeName()
        {
            FuncptrTypeNameContext _localctx = new FuncptrTypeNameContext(Context, State);
            EnterRule(_localctx, 44, RULE_funcptrTypeName);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 349;
                    Match(T__0);
                    State = 350;
                    typeNameList();
                    State = 351;
                    Match(GreaterThan);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class TypeNameListContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Comma() { return GetToken(CixParser.Comma, 0); }
            public TypeNameListContext typeNameList() { return GetRuleContext<TypeNameListContext>(0); }

            public TypeNameListContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_typeNameList; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterTypeNameList(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitTypeNameList(this);
            }
        }

        [RuleVersion(0)]
        public TypeNameListContext typeNameList()
        {
            TypeNameListContext _localctx = new TypeNameListContext(Context, State);
            EnterRule(_localctx, 46, RULE_typeNameList);

            try
            {
                State = 358;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 28, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 353;
                        typeName();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 354;
                        typeName();
                        State = 355;
                        Match(Comma);
                        State = 356;
                        typeNameList();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class PrimitiveTypeContext : ParserRuleContext
        {
            public ITerminalNode Void() { return GetToken(CixParser.Void, 0); }
            public ITerminalNode Short() { return GetToken(CixParser.Short, 0); }
            public ITerminalNode Int() { return GetToken(CixParser.Int, 0); }
            public ITerminalNode Long() { return GetToken(CixParser.Long, 0); }
            public ITerminalNode Float() { return GetToken(CixParser.Float, 0); }
            public ITerminalNode Double() { return GetToken(CixParser.Double, 0); }

            public PrimitiveTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_primitiveType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterPrimitiveType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitPrimitiveType(this);
            }
        }

        [RuleVersion(0)]
        public PrimitiveTypeContext primitiveType()
        {
            PrimitiveTypeContext _localctx = new PrimitiveTypeContext(Context, State);
            EnterRule(_localctx, 48, RULE_primitiveType);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 360;
                    _la = TokenStream.LA(1);

                    if (!((((_la) & ~0x3f) == 0
                        && ((1L << _la)
                            & ((1L << T__1)
                                | (1L << T__2)
                                | (1L << T__3)
                                | (1L << T__4)
                                | (1L << T__5)
                                | (1L << Double)
                                | (1L << Float)
                                | (1L << Int)
                                | (1L << Long)
                                | (1L << Short)
                                | (1L << Void)))
                        != 0))) { ErrorHandler.RecoverInline(this); }
                    else
                    {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class PointerAsteriskListContext : ParserRuleContext
        {
            public ITerminalNode[] Asterisk() { return GetTokens(CixParser.Asterisk); }
            public ITerminalNode Asterisk(int i) { return GetToken(CixParser.Asterisk, i); }

            public PointerAsteriskListContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_pointerAsteriskList; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterPointerAsteriskList(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitPointerAsteriskList(this);
            }
        }

        [RuleVersion(0)]
        public PointerAsteriskListContext pointerAsteriskList()
        {
            PointerAsteriskListContext _localctx = new PointerAsteriskListContext(Context, State);
            EnterRule(_localctx, 50, RULE_pointerAsteriskList);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 363;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    do
                    {
                        {
                            {
                                State = 362;
                                Match(Asterisk);
                            }
                        }
                        State = 365;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    } while (_la == Asterisk);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class VariableDeclarationStatementContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public VariableDeclarationWithInitializationStatementContext
                variableDeclarationWithInitializationStatement()
            {
                return GetRuleContext<VariableDeclarationWithInitializationStatementContext>(0);
            }

            public VariableDeclarationStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_variableDeclarationStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterVariableDeclarationStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitVariableDeclarationStatement(this);
            }
        }

        [RuleVersion(0)]
        public VariableDeclarationStatementContext variableDeclarationStatement()
        {
            VariableDeclarationStatementContext _localctx = new VariableDeclarationStatementContext(Context, State);
            EnterRule(_localctx, 52, RULE_variableDeclarationStatement);

            try
            {
                State = 374;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 30, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 367;
                        typeName();
                        State = 368;
                        Match(Identifier);
                        State = 369;
                        Match(Semicolon);
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 371;
                        variableDeclarationWithInitializationStatement();
                        State = 372;
                        Match(Semicolon);
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class VariableDeclarationWithInitializationStatementContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode Assign() { return GetToken(CixParser.Assign, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public VariableDeclarationWithInitializationStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_variableDeclarationWithInitializationStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterVariableDeclarationWithInitializationStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitVariableDeclarationWithInitializationStatement(this);
            }
        }

        [RuleVersion(0)]
        public VariableDeclarationWithInitializationStatementContext variableDeclarationWithInitializationStatement()
        {
            VariableDeclarationWithInitializationStatementContext _localctx =
                new VariableDeclarationWithInitializationStatementContext(Context, State);
            EnterRule(_localctx, 54, RULE_variableDeclarationWithInitializationStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 376;
                    typeName();
                    State = 377;
                    Match(Identifier);
                    State = 378;
                    Match(Assign);
                    State = 379;
                    expression();
                    State = 380;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class StructContext : ParserRuleContext
        {
            public ITerminalNode Struct() { return GetToken(CixParser.Struct, 0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode OpenScope() { return GetToken(CixParser.OpenScope, 0); }
            public ITerminalNode CloseScope() { return GetToken(CixParser.CloseScope, 0); }
            public StructMemberContext[] structMember() { return GetRuleContexts<StructMemberContext>(); }
            public StructMemberContext structMember(int i) { return GetRuleContext<StructMemberContext>(i); }

            public StructContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_struct; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterStruct(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitStruct(this);
            }
        }

        [RuleVersion(0)]
        public StructContext @struct()
        {
            StructContext _localctx = new StructContext(Context, State);
            EnterRule(_localctx, 56, RULE_struct);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 382;
                    Match(Struct);
                    State = 383;
                    Match(Identifier);
                    State = 384;
                    Match(OpenScope);
                    State = 386;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    do
                    {
                        {
                            {
                                State = 385;
                                structMember();
                            }
                        }
                        State = 388;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    } while ((((_la) & ~0x3f) == 0
                            && ((1L << _la)
                                & ((1L << T__0)
                                    | (1L << T__1)
                                    | (1L << T__2)
                                    | (1L << T__3)
                                    | (1L << T__4)
                                    | (1L << T__5)
                                    | (1L << Double)
                                    | (1L << Float)
                                    | (1L << Int)
                                    | (1L << Long)
                                    | (1L << Short)
                                    | (1L << Void)))
                            != 0)
                        || _la == Identifier);

                    State = 390;
                    Match(CloseScope);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class StructMemberContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }
            public StructArraySizeContext structArraySize() { return GetRuleContext<StructArraySizeContext>(0); }

            public StructMemberContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_structMember; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterStructMember(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitStructMember(this);
            }
        }

        [RuleVersion(0)]
        public StructMemberContext structMember()
        {
            StructMemberContext _localctx = new StructMemberContext(Context, State);
            EnterRule(_localctx, 58, RULE_structMember);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 392;
                    typeName();
                    State = 393;
                    Match(Identifier);
                    State = 395;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    if (_la == LeftBracket)
                    {
                        {
                            State = 394;
                            structArraySize();
                        }
                    }

                    State = 397;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class StructArraySizeContext : ParserRuleContext
        {
            public ITerminalNode LeftBracket() { return GetToken(CixParser.LeftBracket, 0); }
            public ITerminalNode Integer() { return GetToken(CixParser.Integer, 0); }
            public ITerminalNode RightBracket() { return GetToken(CixParser.RightBracket, 0); }

            public StructArraySizeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_structArraySize; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterStructArraySize(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitStructArraySize(this);
            }
        }

        [RuleVersion(0)]
        public StructArraySizeContext structArraySize()
        {
            StructArraySizeContext _localctx = new StructArraySizeContext(Context, State);
            EnterRule(_localctx, 60, RULE_structArraySize);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 399;
                    Match(LeftBracket);
                    State = 400;
                    Match(Integer);
                    State = 401;
                    Match(RightBracket);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class GlobalVariableDeclarationContext : ParserRuleContext
        {
            public ITerminalNode Global() { return GetToken(CixParser.Global, 0); }

            public VariableDeclarationStatementContext variableDeclarationStatement()
            {
                return GetRuleContext<VariableDeclarationStatementContext>(0);
            }

            public VariableDeclarationWithInitializationStatementContext
                variableDeclarationWithInitializationStatement()
            {
                return GetRuleContext<VariableDeclarationWithInitializationStatementContext>(0);
            }

            public GlobalVariableDeclarationContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_globalVariableDeclaration; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterGlobalVariableDeclaration(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitGlobalVariableDeclaration(this);
            }
        }

        [RuleVersion(0)]
        public GlobalVariableDeclarationContext globalVariableDeclaration()
        {
            GlobalVariableDeclarationContext _localctx = new GlobalVariableDeclarationContext(Context, State);
            EnterRule(_localctx, 62, RULE_globalVariableDeclaration);

            try
            {
                State = 407;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 33, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 403;
                        Match(Global);
                        State = 404;
                        variableDeclarationStatement();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 405;
                        Match(Global);
                        State = 406;
                        variableDeclarationWithInitializationStatement();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class FunctionContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public ITerminalNode OpenScope() { return GetToken(CixParser.OpenScope, 0); }
            public ITerminalNode CloseScope() { return GetToken(CixParser.CloseScope, 0); }

            public FunctionParameterListContext functionParameterList()
            {
                return GetRuleContext<FunctionParameterListContext>(0);
            }

            public StatementContext[] statement() { return GetRuleContexts<StatementContext>(); }
            public StatementContext statement(int i) { return GetRuleContext<StatementContext>(i); }

            public FunctionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_function; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterFunction(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitFunction(this);
            }
        }

        [RuleVersion(0)]
        public FunctionContext function()
        {
            FunctionContext _localctx = new FunctionContext(Context, State);
            EnterRule(_localctx, 64, RULE_function);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 409;
                    typeName();
                    State = 410;
                    Match(Identifier);
                    State = 411;
                    Match(LeftParen);
                    State = 413;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    if ((((_la) & ~0x3f) == 0
                            && ((1L << _la)
                                & ((1L << T__0)
                                    | (1L << T__1)
                                    | (1L << T__2)
                                    | (1L << T__3)
                                    | (1L << T__4)
                                    | (1L << T__5)
                                    | (1L << Double)
                                    | (1L << Float)
                                    | (1L << Int)
                                    | (1L << Long)
                                    | (1L << Short)
                                    | (1L << Void)))
                            != 0)
                        || _la == Identifier)
                    {
                        {
                            State = 412;
                            functionParameterList();
                        }
                    }

                    State = 415;
                    Match(RightParen);
                    State = 416;
                    Match(OpenScope);
                    State = 420;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    while ((((_la) & ~0x3f) == 0
                            && ((1L << _la)
                                & ((1L << T__0)
                                    | (1L << T__1)
                                    | (1L << T__2)
                                    | (1L << T__3)
                                    | (1L << T__4)
                                    | (1L << T__5)
                                    | (1L << T__6)
                                    | (1L << Break)
                                    | (1L << Continue)
                                    | (1L << Do)
                                    | (1L << Double)
                                    | (1L << Float)
                                    | (1L << For)
                                    | (1L << If)
                                    | (1L << Int)
                                    | (1L << Long)
                                    | (1L << Return)
                                    | (1L << Short)
                                    | (1L << Sizeof)
                                    | (1L << Void)
                                    | (1L << While)
                                    | (1L << LeftParen)
                                    | (1L << OpenScope)
                                    | (1L << Plus)
                                    | (1L << Increment)
                                    | (1L << Minus)
                                    | (1L << Decrement)
                                    | (1L << Asterisk)
                                    | (1L << Ampersand)
                                    | (1L << LogicalNot)
                                    | (1L << BitwiseNot)))
                            != 0)
                        || ((((_la - 73)) & ~0x3f) == 0
                            && ((1L << (_la - 73))
                                & ((1L << (Integer - 73))
                                    | (1L << (FloatingPoint - 73))
                                    | (1L << (StringLiteral - 73))
                                    | (1L << (Identifier - 73))))
                            != 0))
                    {
                        {
                            {
                                State = 417;
                                statement();
                            }
                        }
                        State = 422;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    }

                    State = 423;
                    Match(CloseScope);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class FunctionParameterListContext : ParserRuleContext
        {
            public FunctionParameterContext functionParameter() { return GetRuleContext<FunctionParameterContext>(0); }
            public ITerminalNode Comma() { return GetToken(CixParser.Comma, 0); }

            public FunctionParameterListContext functionParameterList()
            {
                return GetRuleContext<FunctionParameterListContext>(0);
            }

            public FunctionParameterListContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_functionParameterList; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterFunctionParameterList(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitFunctionParameterList(this);
            }
        }

        [RuleVersion(0)]
        public FunctionParameterListContext functionParameterList()
        {
            FunctionParameterListContext _localctx = new FunctionParameterListContext(Context, State);
            EnterRule(_localctx, 66, RULE_functionParameterList);

            try
            {
                State = 430;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 36, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 425;
                        functionParameter();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 426;
                        functionParameter();
                        State = 427;
                        Match(Comma);
                        State = 428;
                        functionParameterList();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class FunctionParameterContext : ParserRuleContext
        {
            public TypeNameContext typeName() { return GetRuleContext<TypeNameContext>(0); }
            public ITerminalNode Identifier() { return GetToken(CixParser.Identifier, 0); }

            public FunctionParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_functionParameter; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterFunctionParameter(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitFunctionParameter(this);
            }
        }

        [RuleVersion(0)]
        public FunctionParameterContext functionParameter()
        {
            FunctionParameterContext _localctx = new FunctionParameterContext(Context, State);
            EnterRule(_localctx, 68, RULE_functionParameter);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 432;
                    typeName();
                    State = 433;
                    Match(Identifier);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class StatementContext : ParserRuleContext
        {
            public BlockContext block() { return GetRuleContext<BlockContext>(0); }
            public BreakStatementContext breakStatement() { return GetRuleContext<BreakStatementContext>(0); }

            public ConditionalStatementContext conditionalStatement()
            {
                return GetRuleContext<ConditionalStatementContext>(0);
            }

            public ContinueStatementContext continueStatement() { return GetRuleContext<ContinueStatementContext>(0); }
            public DoWhileStatementContext doWhileStatement() { return GetRuleContext<DoWhileStatementContext>(0); }

            public ExpressionStatementContext expressionStatement()
            {
                return GetRuleContext<ExpressionStatementContext>(0);
            }

            public ForStatementContext forStatement() { return GetRuleContext<ForStatementContext>(0); }
            public ReturnStatementContext returnStatement() { return GetRuleContext<ReturnStatementContext>(0); }
            public SwitchStatementContext switchStatement() { return GetRuleContext<SwitchStatementContext>(0); }

            public VariableDeclarationStatementContext variableDeclarationStatement()
            {
                return GetRuleContext<VariableDeclarationStatementContext>(0);
            }

            public VariableDeclarationWithInitializationStatementContext
                variableDeclarationWithInitializationStatement()
            {
                return GetRuleContext<VariableDeclarationWithInitializationStatementContext>(0);
            }

            public WhileStatementContext whileStatement() { return GetRuleContext<WhileStatementContext>(0); }

            public StatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_statement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitStatement(this);
            }
        }

        [RuleVersion(0)]
        public StatementContext statement()
        {
            StatementContext _localctx = new StatementContext(Context, State);
            EnterRule(_localctx, 70, RULE_statement);

            try
            {
                State = 447;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 37, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 435;
                        block();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 436;
                        breakStatement();
                    }

                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);

                    {
                        State = 437;
                        conditionalStatement();
                    }

                        break;
                    case 4:
                        EnterOuterAlt(_localctx, 4);

                    {
                        State = 438;
                        continueStatement();
                    }

                        break;
                    case 5:
                        EnterOuterAlt(_localctx, 5);

                    {
                        State = 439;
                        doWhileStatement();
                    }

                        break;
                    case 6:
                        EnterOuterAlt(_localctx, 6);

                    {
                        State = 440;
                        expressionStatement();
                    }

                        break;
                    case 7:
                        EnterOuterAlt(_localctx, 7);

                    {
                        State = 441;
                        forStatement();
                    }

                        break;
                    case 8:
                        EnterOuterAlt(_localctx, 8);

                    {
                        State = 442;
                        returnStatement();
                    }

                        break;
                    case 9:
                        EnterOuterAlt(_localctx, 9);

                    {
                        State = 443;
                        switchStatement();
                    }

                        break;
                    case 10:
                        EnterOuterAlt(_localctx, 10);

                    {
                        State = 444;
                        variableDeclarationStatement();
                    }

                        break;
                    case 11:
                        EnterOuterAlt(_localctx, 11);

                    {
                        State = 445;
                        variableDeclarationWithInitializationStatement();
                    }

                        break;
                    case 12:
                        EnterOuterAlt(_localctx, 12);

                    {
                        State = 446;
                        whileStatement();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class BlockContext : ParserRuleContext
        {
            public ITerminalNode OpenScope() { return GetToken(CixParser.OpenScope, 0); }
            public ITerminalNode CloseScope() { return GetToken(CixParser.CloseScope, 0); }
            public StatementContext[] statement() { return GetRuleContexts<StatementContext>(); }
            public StatementContext statement(int i) { return GetRuleContext<StatementContext>(i); }

            public BlockContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_block; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterBlock(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitBlock(this);
            }
        }

        [RuleVersion(0)]
        public BlockContext block()
        {
            BlockContext _localctx = new BlockContext(Context, State);
            EnterRule(_localctx, 72, RULE_block);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 449;
                    Match(OpenScope);
                    State = 453;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    while ((((_la) & ~0x3f) == 0
                            && ((1L << _la)
                                & ((1L << T__0)
                                    | (1L << T__1)
                                    | (1L << T__2)
                                    | (1L << T__3)
                                    | (1L << T__4)
                                    | (1L << T__5)
                                    | (1L << T__6)
                                    | (1L << Break)
                                    | (1L << Continue)
                                    | (1L << Do)
                                    | (1L << Double)
                                    | (1L << Float)
                                    | (1L << For)
                                    | (1L << If)
                                    | (1L << Int)
                                    | (1L << Long)
                                    | (1L << Return)
                                    | (1L << Short)
                                    | (1L << Sizeof)
                                    | (1L << Void)
                                    | (1L << While)
                                    | (1L << LeftParen)
                                    | (1L << OpenScope)
                                    | (1L << Plus)
                                    | (1L << Increment)
                                    | (1L << Minus)
                                    | (1L << Decrement)
                                    | (1L << Asterisk)
                                    | (1L << Ampersand)
                                    | (1L << LogicalNot)
                                    | (1L << BitwiseNot)))
                            != 0)
                        || ((((_la - 73)) & ~0x3f) == 0
                            && ((1L << (_la - 73))
                                & ((1L << (Integer - 73))
                                    | (1L << (FloatingPoint - 73))
                                    | (1L << (StringLiteral - 73))
                                    | (1L << (Identifier - 73))))
                            != 0))
                    {
                        {
                            {
                                State = 450;
                                statement();
                            }
                        }
                        State = 455;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    }

                    State = 456;
                    Match(CloseScope);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class BreakStatementContext : ParserRuleContext
        {
            public ITerminalNode Break() { return GetToken(CixParser.Break, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public BreakStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_breakStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterBreakStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitBreakStatement(this);
            }
        }

        [RuleVersion(0)]
        public BreakStatementContext breakStatement()
        {
            BreakStatementContext _localctx = new BreakStatementContext(Context, State);
            EnterRule(_localctx, 74, RULE_breakStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 458;
                    Match(Break);
                    State = 459;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ConditionalStatementContext : ParserRuleContext
        {
            public ITerminalNode If() { return GetToken(CixParser.If, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }
            public ElseStatementContext elseStatement() { return GetRuleContext<ElseStatementContext>(0); }

            public ConditionalStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_conditionalStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterConditionalStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitConditionalStatement(this);
            }
        }

        [RuleVersion(0)]
        public ConditionalStatementContext conditionalStatement()
        {
            ConditionalStatementContext _localctx = new ConditionalStatementContext(Context, State);
            EnterRule(_localctx, 76, RULE_conditionalStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 461;
                    Match(If);
                    State = 462;
                    Match(LeftParen);
                    State = 463;
                    expression();
                    State = 464;
                    Match(RightParen);
                    State = 465;
                    statement();
                    State = 467;
                    ErrorHandler.Sync(this);

                    switch (Interpreter.AdaptivePredict(TokenStream, 39, Context))
                    {
                        case 1:
                        {
                            State = 466;
                            elseStatement();
                        }

                            break;
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ContinueStatementContext : ParserRuleContext
        {
            public ITerminalNode Continue() { return GetToken(CixParser.Continue, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public ContinueStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_continueStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterContinueStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitContinueStatement(this);
            }
        }

        [RuleVersion(0)]
        public ContinueStatementContext continueStatement()
        {
            ContinueStatementContext _localctx = new ContinueStatementContext(Context, State);
            EnterRule(_localctx, 78, RULE_continueStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 469;
                    Match(Continue);
                    State = 470;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ElseStatementContext : ParserRuleContext
        {
            public ITerminalNode Else() { return GetToken(CixParser.Else, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }

            public ElseStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_elseStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterElseStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitElseStatement(this);
            }
        }

        [RuleVersion(0)]
        public ElseStatementContext elseStatement()
        {
            ElseStatementContext _localctx = new ElseStatementContext(Context, State);
            EnterRule(_localctx, 80, RULE_elseStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 472;
                    Match(Else);
                    State = 473;
                    statement();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class DoWhileStatementContext : ParserRuleContext
        {
            public ITerminalNode Do() { return GetToken(CixParser.Do, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }
            public ITerminalNode While() { return GetToken(CixParser.While, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public DoWhileStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_doWhileStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterDoWhileStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitDoWhileStatement(this);
            }
        }

        [RuleVersion(0)]
        public DoWhileStatementContext doWhileStatement()
        {
            DoWhileStatementContext _localctx = new DoWhileStatementContext(Context, State);
            EnterRule(_localctx, 82, RULE_doWhileStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 475;
                    Match(Do);
                    State = 476;
                    statement();
                    State = 477;
                    Match(While);
                    State = 478;
                    Match(LeftParen);
                    State = 479;
                    expression();
                    State = 480;
                    Match(RightParen);
                    State = 481;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ExpressionStatementContext : ParserRuleContext
        {
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }

            public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_expressionStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterExpressionStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitExpressionStatement(this);
            }
        }

        [RuleVersion(0)]
        public ExpressionStatementContext expressionStatement()
        {
            ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
            EnterRule(_localctx, 84, RULE_expressionStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 483;
                    expression();
                    State = 484;
                    Match(Semicolon);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ForStatementContext : ParserRuleContext
        {
            public ITerminalNode For() { return GetToken(CixParser.For, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext[] expression() { return GetRuleContexts<ExpressionContext>(); }
            public ExpressionContext expression(int i) { return GetRuleContext<ExpressionContext>(i); }
            public ITerminalNode[] Semicolon() { return GetTokens(CixParser.Semicolon); }
            public ITerminalNode Semicolon(int i) { return GetToken(CixParser.Semicolon, i); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }

            public ForStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_forStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterForStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitForStatement(this);
            }
        }

        [RuleVersion(0)]
        public ForStatementContext forStatement()
        {
            ForStatementContext _localctx = new ForStatementContext(Context, State);
            EnterRule(_localctx, 86, RULE_forStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 486;
                    Match(For);
                    State = 487;
                    Match(LeftParen);
                    State = 488;
                    expression();
                    State = 489;
                    Match(Semicolon);
                    State = 490;
                    expression();
                    State = 491;
                    Match(Semicolon);
                    State = 492;
                    expression();
                    State = 493;
                    Match(Semicolon);
                    State = 494;
                    Match(RightParen);
                    State = 495;
                    statement();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class ReturnStatementContext : ParserRuleContext
        {
            public ITerminalNode Return() { return GetToken(CixParser.Return, 0); }
            public ITerminalNode Semicolon() { return GetToken(CixParser.Semicolon, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }

            public ReturnStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_returnStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterReturnStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitReturnStatement(this);
            }
        }

        [RuleVersion(0)]
        public ReturnStatementContext returnStatement()
        {
            ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
            EnterRule(_localctx, 88, RULE_returnStatement);

            try
            {
                State = 503;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 40, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 497;
                        Match(Return);
                        State = 498;
                        Match(Semicolon);
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 499;
                        Match(Return);
                        State = 500;
                        expression();
                        State = 501;
                        Match(Semicolon);
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class SwitchStatementContext : ParserRuleContext
        {
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public ITerminalNode OpenScope() { return GetToken(CixParser.OpenScope, 0); }
            public ITerminalNode CloseScope() { return GetToken(CixParser.CloseScope, 0); }
            public CaseStatementContext[] caseStatement() { return GetRuleContexts<CaseStatementContext>(); }
            public CaseStatementContext caseStatement(int i) { return GetRuleContext<CaseStatementContext>(i); }

            public SwitchStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_switchStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterSwitchStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitSwitchStatement(this);
            }
        }

        [RuleVersion(0)]
        public SwitchStatementContext switchStatement()
        {
            SwitchStatementContext _localctx = new SwitchStatementContext(Context, State);
            EnterRule(_localctx, 90, RULE_switchStatement);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 505;
                    Match(T__6);
                    State = 506;
                    Match(LeftParen);
                    State = 507;
                    expression();
                    State = 508;
                    Match(RightParen);
                    State = 509;
                    Match(OpenScope);
                    State = 511;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    do
                    {
                        {
                            {
                                State = 510;
                                caseStatement();
                            }
                        }
                        State = 513;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    } while (_la == Case || _la == Default);

                    State = 515;
                    Match(CloseScope);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class CaseStatementContext : ParserRuleContext
        {
            public LiteralCaseStatementContext literalCaseStatement()
            {
                return GetRuleContext<LiteralCaseStatementContext>(0);
            }

            public DefaultCaseStatementContext defaultCaseStatement()
            {
                return GetRuleContext<DefaultCaseStatementContext>(0);
            }

            public CaseStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_caseStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterCaseStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitCaseStatement(this);
            }
        }

        [RuleVersion(0)]
        public CaseStatementContext caseStatement()
        {
            CaseStatementContext _localctx = new CaseStatementContext(Context, State);
            EnterRule(_localctx, 92, RULE_caseStatement);

            try
            {
                State = 519;
                ErrorHandler.Sync(this);

                switch (TokenStream.LA(1))
                {
                    case Case:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 517;
                        literalCaseStatement();
                    }

                        break;
                    case Default:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 518;
                        defaultCaseStatement();
                    }

                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class LiteralCaseStatementContext : ParserRuleContext
        {
            public ITerminalNode Case() { return GetToken(CixParser.Case, 0); }
            public ITerminalNode Integer() { return GetToken(CixParser.Integer, 0); }
            public ITerminalNode Colon() { return GetToken(CixParser.Colon, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }
            public ITerminalNode StringLiteral() { return GetToken(CixParser.StringLiteral, 0); }

            public LiteralCaseStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_literalCaseStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterLiteralCaseStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitLiteralCaseStatement(this);
            }
        }

        [RuleVersion(0)]
        public LiteralCaseStatementContext literalCaseStatement()
        {
            LiteralCaseStatementContext _localctx = new LiteralCaseStatementContext(Context, State);
            EnterRule(_localctx, 94, RULE_literalCaseStatement);

            try
            {
                State = 529;
                ErrorHandler.Sync(this);

                switch (Interpreter.AdaptivePredict(TokenStream, 43, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);

                    {
                        State = 521;
                        Match(Case);
                        State = 522;
                        Match(Integer);
                        State = 523;
                        Match(Colon);
                        State = 524;
                        statement();
                    }

                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);

                    {
                        State = 525;
                        Match(Case);
                        State = 526;
                        Match(StringLiteral);
                        State = 527;
                        Match(Colon);
                        State = 528;
                        statement();
                    }

                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class DefaultCaseStatementContext : ParserRuleContext
        {
            public ITerminalNode Default() { return GetToken(CixParser.Default, 0); }
            public ITerminalNode Colon() { return GetToken(CixParser.Colon, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }

            public DefaultCaseStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_defaultCaseStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterDefaultCaseStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitDefaultCaseStatement(this);
            }
        }

        [RuleVersion(0)]
        public DefaultCaseStatementContext defaultCaseStatement()
        {
            DefaultCaseStatementContext _localctx = new DefaultCaseStatementContext(Context, State);
            EnterRule(_localctx, 96, RULE_defaultCaseStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 531;
                    Match(Default);
                    State = 532;
                    Match(Colon);
                    State = 533;
                    statement();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class WhileStatementContext : ParserRuleContext
        {
            public ITerminalNode While() { return GetToken(CixParser.While, 0); }
            public ITerminalNode LeftParen() { return GetToken(CixParser.LeftParen, 0); }
            public ExpressionContext expression() { return GetRuleContext<ExpressionContext>(0); }
            public ITerminalNode RightParen() { return GetToken(CixParser.RightParen, 0); }
            public StatementContext statement() { return GetRuleContext<StatementContext>(0); }

            public WhileStatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_whileStatement; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterWhileStatement(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitWhileStatement(this);
            }
        }

        [RuleVersion(0)]
        public WhileStatementContext whileStatement()
        {
            WhileStatementContext _localctx = new WhileStatementContext(Context, State);
            EnterRule(_localctx, 98, RULE_whileStatement);

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 535;
                    Match(While);
                    State = 536;
                    Match(LeftParen);
                    State = 537;
                    expression();
                    State = 538;
                    Match(RightParen);
                    State = 539;
                    statement();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class NumberContext : ParserRuleContext
        {
            public ITerminalNode Integer() { return GetToken(CixParser.Integer, 0); }
            public ITerminalNode FloatingPoint() { return GetToken(CixParser.FloatingPoint, 0); }

            public NumberContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_number; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterNumber(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitNumber(this);
            }
        }

        [RuleVersion(0)]
        public NumberContext number()
        {
            NumberContext _localctx = new NumberContext(Context, State);
            EnterRule(_localctx, 100, RULE_number);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 541;
                    _la = TokenStream.LA(1);

                    if (!(_la == Integer || _la == FloatingPoint)) { ErrorHandler.RecoverInline(this); }
                    else
                    {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public partial class SourceFileContext : ParserRuleContext
        {
            public StructContext[] @struct() { return GetRuleContexts<StructContext>(); }
            public StructContext @struct(int i) { return GetRuleContext<StructContext>(i); }

            public GlobalVariableDeclarationContext[] globalVariableDeclaration()
            {
                return GetRuleContexts<GlobalVariableDeclarationContext>();
            }

            public GlobalVariableDeclarationContext globalVariableDeclaration(int i)
            {
                return GetRuleContext<GlobalVariableDeclarationContext>(i);
            }

            public FunctionContext[] function() { return GetRuleContexts<FunctionContext>(); }
            public FunctionContext function(int i) { return GetRuleContext<FunctionContext>(i); }

            public SourceFileContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }

            public override int RuleIndex
            {
                get { return RULE_sourceFile; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.EnterSourceFile(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ICixListener typedListener = listener as ICixListener;
                if (typedListener != null) typedListener.ExitSourceFile(this);
            }
        }

        [RuleVersion(0)]
        public SourceFileContext sourceFile()
        {
            SourceFileContext _localctx = new SourceFileContext(Context, State);
            EnterRule(_localctx, 102, RULE_sourceFile);
            int _la;

            try
            {
                EnterOuterAlt(_localctx, 1);

                {
                    State = 546;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);

                    do
                    {
                        {
                            State = 546;
                            ErrorHandler.Sync(this);

                            switch (TokenStream.LA(1))
                            {
                                case Struct:
                                {
                                    State = 543;
                                    @struct();
                                }

                                    break;
                                case Global:
                                {
                                    State = 544;
                                    globalVariableDeclaration();
                                }

                                    break;
                                case T__0:
                                case T__1:
                                case T__2:
                                case T__3:
                                case T__4:
                                case T__5:
                                case Double:
                                case Float:
                                case Int:
                                case Long:
                                case Short:
                                case Void:
                                case Identifier:
                                {
                                    State = 545;
                                    function();
                                }

                                    break;
                                default:
                                    throw new NoViableAltException(this);
                            }
                        }
                        State = 548;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    } while ((((_la) & ~0x3f) == 0
                            && ((1L << _la)
                                & ((1L << T__0)
                                    | (1L << T__1)
                                    | (1L << T__2)
                                    | (1L << T__3)
                                    | (1L << T__4)
                                    | (1L << T__5)
                                    | (1L << Double)
                                    | (1L << Float)
                                    | (1L << Global)
                                    | (1L << Int)
                                    | (1L << Long)
                                    | (1L << Short)
                                    | (1L << Struct)
                                    | (1L << Void)))
                            != 0)
                        || _la == Identifier);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally { ExitRule(); }

            return _localctx;
        }

        public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex)
        {
            switch (ruleIndex)
            {
                case 1: return postfixExpression_sempred((PostfixExpressionContext)_localctx, predIndex);
                case 2: return argumentExpressionList_sempred((ArgumentExpressionListContext)_localctx, predIndex);
                case 6: return multiplicativeExpression_sempred((MultiplicativeExpressionContext)_localctx, predIndex);
                case 7: return additiveExpression_sempred((AdditiveExpressionContext)_localctx, predIndex);
                case 8: return shiftExpression_sempred((ShiftExpressionContext)_localctx, predIndex);
                case 9: return relationalExpression_sempred((RelationalExpressionContext)_localctx, predIndex);
                case 10: return equalityExpression_sempred((EqualityExpressionContext)_localctx, predIndex);
                case 11: return andExpression_sempred((AndExpressionContext)_localctx, predIndex);
                case 12: return exclusiveOrExpression_sempred((ExclusiveOrExpressionContext)_localctx, predIndex);
                case 13: return inclusiveOrExpression_sempred((InclusiveOrExpressionContext)_localctx, predIndex);
                case 14: return logicalAndExpression_sempred((LogicalAndExpressionContext)_localctx, predIndex);
                case 15: return logicalOrExpression_sempred((LogicalOrExpressionContext)_localctx, predIndex);
            }

            return true;
        }

        private bool postfixExpression_sempred(PostfixExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 0: return Precpred(Context, 6);
                case 1: return Precpred(Context, 5);
                case 2: return Precpred(Context, 4);
                case 3: return Precpred(Context, 3);
                case 4: return Precpred(Context, 2);
                case 5: return Precpred(Context, 1);
            }

            return true;
        }

        private bool argumentExpressionList_sempred(ArgumentExpressionListContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 6: return Precpred(Context, 1);
            }

            return true;
        }

        private bool multiplicativeExpression_sempred(MultiplicativeExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 7: return Precpred(Context, 3);
                case 8: return Precpred(Context, 2);
                case 9: return Precpred(Context, 1);
            }

            return true;
        }

        private bool additiveExpression_sempred(AdditiveExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 10: return Precpred(Context, 2);
                case 11: return Precpred(Context, 1);
            }

            return true;
        }

        private bool shiftExpression_sempred(ShiftExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 12: return Precpred(Context, 2);
                case 13: return Precpred(Context, 1);
            }

            return true;
        }

        private bool relationalExpression_sempred(RelationalExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 14: return Precpred(Context, 4);
                case 15: return Precpred(Context, 3);
                case 16: return Precpred(Context, 2);
                case 17: return Precpred(Context, 1);
            }

            return true;
        }

        private bool equalityExpression_sempred(EqualityExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 18: return Precpred(Context, 2);
                case 19: return Precpred(Context, 1);
            }

            return true;
        }

        private bool andExpression_sempred(AndExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 20: return Precpred(Context, 1);
            }

            return true;
        }

        private bool exclusiveOrExpression_sempred(ExclusiveOrExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 21: return Precpred(Context, 1);
            }

            return true;
        }

        private bool inclusiveOrExpression_sempred(InclusiveOrExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 22: return Precpred(Context, 1);
            }

            return true;
        }

        private bool logicalAndExpression_sempred(LogicalAndExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 23: return Precpred(Context, 1);
            }

            return true;
        }

        private bool logicalOrExpression_sempred(LogicalOrExpressionContext _localctx, int predIndex)
        {
            switch (predIndex)
            {
                case 24: return Precpred(Context, 1);
            }

            return true;
        }

        private static char[] _serializedATN =
        {
            '\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED',
            '\x417C', '\x3BE7', '\x7786', '\x5964', '\x3',
            'R', '\x229', '\x4', '\x2', '\t',
            '\x2', '\x4', '\x3', '\t', '\x3',
            '\x4', '\x4', '\t', '\x4', '\x4',
            '\x5', '\t', '\x5', '\x4', '\x6',
            '\t', '\x6', '\x4', '\a', '\t',
            '\a', '\x4', '\b', '\t', '\b',
            '\x4', '\t', '\t', '\t', '\x4',
            '\n', '\t', '\n', '\x4', '\v',
            '\t', '\v', '\x4', '\f', '\t',
            '\f', '\x4', '\r', '\t', '\r',
            '\x4', '\xE', '\t', '\xE', '\x4',
            '\xF', '\t', '\xF', '\x4', '\x10',
            '\t', '\x10', '\x4', '\x11', '\t',
            '\x11', '\x4', '\x12', '\t', '\x12',
            '\x4', '\x13', '\t', '\x13', '\x4',
            '\x14', '\t', '\x14', '\x4', '\x15',
            '\t', '\x15', '\x4', '\x16', '\t',
            '\x16', '\x4', '\x17', '\t', '\x17',
            '\x4', '\x18', '\t', '\x18', '\x4',
            '\x19', '\t', '\x19', '\x4', '\x1A',
            '\t', '\x1A', '\x4', '\x1B', '\t',
            '\x1B', '\x4', '\x1C', '\t', '\x1C',
            '\x4', '\x1D', '\t', '\x1D', '\x4',
            '\x1E', '\t', '\x1E', '\x4', '\x1F',
            '\t', '\x1F', '\x4', ' ', '\t',
            ' ', '\x4', '!', '\t', '!',
            '\x4', '\"', '\t', '\"', '\x4',
            '#', '\t', '#', '\x4', '$',
            '\t', '$', '\x4', '%', '\t',
            '%', '\x4', '&', '\t', '&',
            '\x4', '\'', '\t', '\'', '\x4',
            '(', '\t', '(', '\x4', ')',
            '\t', ')', '\x4', '*', '\t',
            '*', '\x4', '+', '\t', '+',
            '\x4', ',', '\t', ',', '\x4',
            '-', '\t', '-', '\x4', '.',
            '\t', '.', '\x4', '/', '\t',
            '/', '\x4', '\x30', '\t', '\x30',
            '\x4', '\x31', '\t', '\x31', '\x4',
            '\x32', '\t', '\x32', '\x4', '\x33',
            '\t', '\x33', '\x4', '\x34', '\t',
            '\x34', '\x4', '\x35', '\t', '\x35',
            '\x3', '\x2', '\x3', '\x2', '\x3',
            '\x2', '\x3', '\x2', '\x3', '\x2',
            '\x3', '\x2', '\x3', '\x2', '\x5',
            '\x2', 'r', '\n', '\x2', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x5', '\x3', '\x7F', '\n',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\x3', '\x3',
            '\x3', '\x3', '\x3', '\a', '\x3',
            '\x8C', '\n', '\x3', '\f', '\x3',
            '\xE', '\x3', '\x8F', '\v', '\x3',
            '\x3', '\x4', '\x3', '\x4', '\x3',
            '\x4', '\x3', '\x4', '\x3', '\x4',
            '\x3', '\x4', '\a', '\x4', '\x97',
            '\n', '\x4', '\f', '\x4', '\xE',
            '\x4', '\x9A', '\v', '\x4', '\x3',
            '\x5', '\x3', '\x5', '\x3', '\x5',
            '\x3', '\x5', '\x3', '\x5', '\x3',
            '\x5', '\x3', '\x5', '\x3', '\x5',
            '\x3', '\x5', '\x3', '\x5', '\x3',
            '\x5', '\x3', '\x5', '\x3', '\x5',
            '\x3', '\x5', '\x3', '\x5', '\x5',
            '\x5', '\xAB', '\n', '\x5', '\x3',
            '\x6', '\x3', '\x6', '\x3', '\a',
            '\x3', '\a', '\x3', '\a', '\x3',
            '\a', '\x3', '\a', '\x3', '\a',
            '\x5', '\a', '\xB5', '\n', '\a',
            '\x3', '\b', '\x3', '\b', '\x3',
            '\b', '\x3', '\b', '\x3', '\b',
            '\x3', '\b', '\x3', '\b', '\x3',
            '\b', '\x3', '\b', '\x3', '\b',
            '\x3', '\b', '\x3', '\b', '\a',
            '\b', '\xC3', '\n', '\b', '\f',
            '\b', '\xE', '\b', '\xC6', '\v',
            '\b', '\x3', '\t', '\x3', '\t',
            '\x3', '\t', '\x3', '\t', '\x3',
            '\t', '\x3', '\t', '\x3', '\t',
            '\x3', '\t', '\x3', '\t', '\a',
            '\t', '\xD1', '\n', '\t', '\f',
            '\t', '\xE', '\t', '\xD4', '\v',
            '\t', '\x3', '\n', '\x3', '\n',
            '\x3', '\n', '\x3', '\n', '\x3',
            '\n', '\x3', '\n', '\x3', '\n',
            '\x3', '\n', '\x3', '\n', '\a',
            '\n', '\xDF', '\n', '\n', '\f',
            '\n', '\xE', '\n', '\xE2', '\v',
            '\n', '\x3', '\v', '\x3', '\v',
            '\x3', '\v', '\x3', '\v', '\x3',
            '\v', '\x3', '\v', '\x3', '\v',
            '\x3', '\v', '\x3', '\v', '\x3',
            '\v', '\x3', '\v', '\x3', '\v',
            '\x3', '\v', '\x3', '\v', '\x3',
            '\v', '\a', '\v', '\xF3', '\n',
            '\v', '\f', '\v', '\xE', '\v',
            '\xF6', '\v', '\v', '\x3', '\f',
            '\x3', '\f', '\x3', '\f', '\x3',
            '\f', '\x3', '\f', '\x3', '\f',
            '\x3', '\f', '\x3', '\f', '\x3',
            '\f', '\a', '\f', '\x101', '\n',
            '\f', '\f', '\f', '\xE', '\f',
            '\x104', '\v', '\f', '\x3', '\r',
            '\x3', '\r', '\x3', '\r', '\x3',
            '\r', '\x3', '\r', '\x3', '\r',
            '\a', '\r', '\x10C', '\n', '\r',
            '\f', '\r', '\xE', '\r', '\x10F',
            '\v', '\r', '\x3', '\xE', '\x3',
            '\xE', '\x3', '\xE', '\x3', '\xE',
            '\x3', '\xE', '\x3', '\xE', '\a',
            '\xE', '\x117', '\n', '\xE', '\f',
            '\xE', '\xE', '\xE', '\x11A', '\v',
            '\xE', '\x3', '\xF', '\x3', '\xF',
            '\x3', '\xF', '\x3', '\xF', '\x3',
            '\xF', '\x3', '\xF', '\a', '\xF',
            '\x122', '\n', '\xF', '\f', '\xF',
            '\xE', '\xF', '\x125', '\v', '\xF',
            '\x3', '\x10', '\x3', '\x10', '\x3',
            '\x10', '\x3', '\x10', '\x3', '\x10',
            '\x3', '\x10', '\a', '\x10', '\x12D',
            '\n', '\x10', '\f', '\x10', '\xE',
            '\x10', '\x130', '\v', '\x10', '\x3',
            '\x11', '\x3', '\x11', '\x3', '\x11',
            '\x3', '\x11', '\x3', '\x11', '\x3',
            '\x11', '\a', '\x11', '\x138', '\n',
            '\x11', '\f', '\x11', '\xE', '\x11',
            '\x13B', '\v', '\x11', '\x3', '\x12',
            '\x3', '\x12', '\x3', '\x12', '\x3',
            '\x12', '\x3', '\x12', '\x3', '\x12',
            '\x5', '\x12', '\x143', '\n', '\x12',
            '\x3', '\x13', '\x3', '\x13', '\x3',
            '\x13', '\x3', '\x13', '\x3', '\x13',
            '\x5', '\x13', '\x14A', '\n', '\x13',
            '\x3', '\x14', '\x3', '\x14', '\x3',
            '\x15', '\x3', '\x15', '\x3', '\x16',
            '\x3', '\x16', '\x3', '\x17', '\x3',
            '\x17', '\x5', '\x17', '\x154', '\n',
            '\x17', '\x3', '\x17', '\x3', '\x17',
            '\x5', '\x17', '\x158', '\n', '\x17',
            '\x3', '\x17', '\x3', '\x17', '\x5',
            '\x17', '\x15C', '\n', '\x17', '\x5',
            '\x17', '\x15E', '\n', '\x17', '\x3',
            '\x18', '\x3', '\x18', '\x3', '\x18',
            '\x3', '\x18', '\x3', '\x19', '\x3',
            '\x19', '\x3', '\x19', '\x3', '\x19',
            '\x3', '\x19', '\x5', '\x19', '\x169',
            '\n', '\x19', '\x3', '\x1A', '\x3',
            '\x1A', '\x3', '\x1B', '\x6', '\x1B',
            '\x16E', '\n', '\x1B', '\r', '\x1B',
            '\xE', '\x1B', '\x16F', '\x3', '\x1C',
            '\x3', '\x1C', '\x3', '\x1C', '\x3',
            '\x1C', '\x3', '\x1C', '\x3', '\x1C',
            '\x3', '\x1C', '\x5', '\x1C', '\x179',
            '\n', '\x1C', '\x3', '\x1D', '\x3',
            '\x1D', '\x3', '\x1D', '\x3', '\x1D',
            '\x3', '\x1D', '\x3', '\x1D', '\x3',
            '\x1E', '\x3', '\x1E', '\x3', '\x1E',
            '\x3', '\x1E', '\x6', '\x1E', '\x185',
            '\n', '\x1E', '\r', '\x1E', '\xE',
            '\x1E', '\x186', '\x3', '\x1E', '\x3',
            '\x1E', '\x3', '\x1F', '\x3', '\x1F',
            '\x3', '\x1F', '\x5', '\x1F', '\x18E',
            '\n', '\x1F', '\x3', '\x1F', '\x3',
            '\x1F', '\x3', ' ', '\x3', ' ',
            '\x3', ' ', '\x3', ' ', '\x3',
            '!', '\x3', '!', '\x3', '!',
            '\x3', '!', '\x5', '!', '\x19A',
            '\n', '!', '\x3', '\"', '\x3',
            '\"', '\x3', '\"', '\x3', '\"',
            '\x5', '\"', '\x1A0', '\n', '\"',
            '\x3', '\"', '\x3', '\"', '\x3',
            '\"', '\a', '\"', '\x1A5', '\n',
            '\"', '\f', '\"', '\xE', '\"',
            '\x1A8', '\v', '\"', '\x3', '\"',
            '\x3', '\"', '\x3', '#', '\x3',
            '#', '\x3', '#', '\x3', '#',
            '\x3', '#', '\x5', '#', '\x1B1',
            '\n', '#', '\x3', '$', '\x3',
            '$', '\x3', '$', '\x3', '%',
            '\x3', '%', '\x3', '%', '\x3',
            '%', '\x3', '%', '\x3', '%',
            '\x3', '%', '\x3', '%', '\x3',
            '%', '\x3', '%', '\x3', '%',
            '\x3', '%', '\x5', '%', '\x1C2',
            '\n', '%', '\x3', '&', '\x3',
            '&', '\a', '&', '\x1C6', '\n',
            '&', '\f', '&', '\xE', '&',
            '\x1C9', '\v', '&', '\x3', '&',
            '\x3', '&', '\x3', '\'', '\x3',
            '\'', '\x3', '\'', '\x3', '(',
            '\x3', '(', '\x3', '(', '\x3',
            '(', '\x3', '(', '\x3', '(',
            '\x5', '(', '\x1D6', '\n', '(',
            '\x3', ')', '\x3', ')', '\x3',
            ')', '\x3', '*', '\x3', '*',
            '\x3', '*', '\x3', '+', '\x3',
            '+', '\x3', '+', '\x3', '+',
            '\x3', '+', '\x3', '+', '\x3',
            '+', '\x3', '+', '\x3', ',',
            '\x3', ',', '\x3', ',', '\x3',
            '-', '\x3', '-', '\x3', '-',
            '\x3', '-', '\x3', '-', '\x3',
            '-', '\x3', '-', '\x3', '-',
            '\x3', '-', '\x3', '-', '\x3',
            '-', '\x3', '.', '\x3', '.',
            '\x3', '.', '\x3', '.', '\x3',
            '.', '\x3', '.', '\x5', '.',
            '\x1FA', '\n', '.', '\x3', '/',
            '\x3', '/', '\x3', '/', '\x3',
            '/', '\x3', '/', '\x3', '/',
            '\x6', '/', '\x202', '\n', '/',
            '\r', '/', '\xE', '/', '\x203',
            '\x3', '/', '\x3', '/', '\x3',
            '\x30', '\x3', '\x30', '\x5', '\x30',
            '\x20A', '\n', '\x30', '\x3', '\x31',
            '\x3', '\x31', '\x3', '\x31', '\x3',
            '\x31', '\x3', '\x31', '\x3', '\x31',
            '\x3', '\x31', '\x3', '\x31', '\x5',
            '\x31', '\x214', '\n', '\x31', '\x3',
            '\x32', '\x3', '\x32', '\x3', '\x32',
            '\x3', '\x32', '\x3', '\x33', '\x3',
            '\x33', '\x3', '\x33', '\x3', '\x33',
            '\x3', '\x33', '\x3', '\x33', '\x3',
            '\x34', '\x3', '\x34', '\x3', '\x35',
            '\x3', '\x35', '\x3', '\x35', '\x6',
            '\x35', '\x225', '\n', '\x35', '\r',
            '\x35', '\xE', '\x35', '\x226', '\x3',
            '\x35', '\x2', '\xE', '\x4', '\x6',
            '\xE', '\x10', '\x12', '\x14', '\x16',
            '\x18', '\x1A', '\x1C', '\x1E', ' ',
            '\x36', '\x2', '\x4', '\x6', '\b',
            '\n', '\f', '\xE', '\x10', '\x12',
            '\x14', '\x16', '\x18', '\x1A', '\x1C',
            '\x1E', ' ', '\"', '$', '&',
            '(', '*', ',', '.', '\x30',
            '\x32', '\x34', '\x36', '\x38', ':',
            '<', '>', '@', '\x42', '\x44',
            '\x46', 'H', 'J', 'L', 'N',
            'P', 'R', 'T', 'V', 'X',
            'Z', '\\', '^', '`', '\x62',
            '\x64', '\x66', 'h', '\x2', '\x6',
            '\a', '\x2', '*', '*', ',',
            ',', '.', '.', '\x31', '\x31',
            '\x36', '\x37', '\x3', '\x2', '<',
            '\x46', '\b', '\x2', '\x4', '\b',
            '\x10', '\x10', '\x12', '\x12', '\x16',
            '\x17', '\x19', '\x19', '\x1C', '\x1C',
            '\x3', '\x2', 'K', 'L', '\x2',
            '\x23B', '\x2', 'q', '\x3', '\x2',
            '\x2', '\x2', '\x4', 's', '\x3',
            '\x2', '\x2', '\x2', '\x6', '\x90',
            '\x3', '\x2', '\x2', '\x2', '\b',
            '\xAA', '\x3', '\x2', '\x2', '\x2',
            '\n', '\xAC', '\x3', '\x2', '\x2',
            '\x2', '\f', '\xB4', '\x3', '\x2',
            '\x2', '\x2', '\xE', '\xB6', '\x3',
            '\x2', '\x2', '\x2', '\x10', '\xC7',
            '\x3', '\x2', '\x2', '\x2', '\x12',
            '\xD5', '\x3', '\x2', '\x2', '\x2',
            '\x14', '\xE3', '\x3', '\x2', '\x2',
            '\x2', '\x16', '\xF7', '\x3', '\x2',
            '\x2', '\x2', '\x18', '\x105', '\x3',
            '\x2', '\x2', '\x2', '\x1A', '\x110',
            '\x3', '\x2', '\x2', '\x2', '\x1C',
            '\x11B', '\x3', '\x2', '\x2', '\x2',
            '\x1E', '\x126', '\x3', '\x2', '\x2',
            '\x2', ' ', '\x131', '\x3', '\x2',
            '\x2', '\x2', '\"', '\x13C', '\x3',
            '\x2', '\x2', '\x2', '$', '\x149',
            '\x3', '\x2', '\x2', '\x2', '&',
            '\x14B', '\x3', '\x2', '\x2', '\x2',
            '(', '\x14D', '\x3', '\x2', '\x2',
            '\x2', '*', '\x14F', '\x3', '\x2',
            '\x2', '\x2', ',', '\x15D', '\x3',
            '\x2', '\x2', '\x2', '.', '\x15F',
            '\x3', '\x2', '\x2', '\x2', '\x30',
            '\x168', '\x3', '\x2', '\x2', '\x2',
            '\x32', '\x16A', '\x3', '\x2', '\x2',
            '\x2', '\x34', '\x16D', '\x3', '\x2',
            '\x2', '\x2', '\x36', '\x178', '\x3',
            '\x2', '\x2', '\x2', '\x38', '\x17A',
            '\x3', '\x2', '\x2', '\x2', ':',
            '\x180', '\x3', '\x2', '\x2', '\x2',
            '<', '\x18A', '\x3', '\x2', '\x2',
            '\x2', '>', '\x191', '\x3', '\x2',
            '\x2', '\x2', '@', '\x199', '\x3',
            '\x2', '\x2', '\x2', '\x42', '\x19B',
            '\x3', '\x2', '\x2', '\x2', '\x44',
            '\x1B0', '\x3', '\x2', '\x2', '\x2',
            '\x46', '\x1B2', '\x3', '\x2', '\x2',
            '\x2', 'H', '\x1C1', '\x3', '\x2',
            '\x2', '\x2', 'J', '\x1C3', '\x3',
            '\x2', '\x2', '\x2', 'L', '\x1CC',
            '\x3', '\x2', '\x2', '\x2', 'N',
            '\x1CF', '\x3', '\x2', '\x2', '\x2',
            'P', '\x1D7', '\x3', '\x2', '\x2',
            '\x2', 'R', '\x1DA', '\x3', '\x2',
            '\x2', '\x2', 'T', '\x1DD', '\x3',
            '\x2', '\x2', '\x2', 'V', '\x1E5',
            '\x3', '\x2', '\x2', '\x2', 'X',
            '\x1E8', '\x3', '\x2', '\x2', '\x2',
            'Z', '\x1F9', '\x3', '\x2', '\x2',
            '\x2', '\\', '\x1FB', '\x3', '\x2',
            '\x2', '\x2', '^', '\x209', '\x3',
            '\x2', '\x2', '\x2', '`', '\x213',
            '\x3', '\x2', '\x2', '\x2', '\x62',
            '\x215', '\x3', '\x2', '\x2', '\x2',
            '\x64', '\x219', '\x3', '\x2', '\x2',
            '\x2', '\x66', '\x21F', '\x3', '\x2',
            '\x2', '\x2', 'h', '\x224', '\x3',
            '\x2', '\x2', '\x2', 'j', 'r',
            '\a', 'O', '\x2', '\x2', 'k',
            'r', '\a', 'N', '\x2', '\x2',
            'l', 'r', '\x5', '\x66', '\x34',
            '\x2', 'm', 'n', '\a', '\x1E',
            '\x2', '\x2', 'n', 'o', '\x5',
            '(', '\x15', '\x2', 'o', 'p',
            '\a', '\x1F', '\x2', '\x2', 'p',
            'r', '\x3', '\x2', '\x2', '\x2',
            'q', 'j', '\x3', '\x2', '\x2',
            '\x2', 'q', 'k', '\x3', '\x2',
            '\x2', '\x2', 'q', 'l', '\x3',
            '\x2', '\x2', '\x2', 'q', 'm',
            '\x3', '\x2', '\x2', '\x2', 'r',
            '\x3', '\x3', '\x2', '\x2', '\x2',
            's', 't', '\b', '\x3', '\x1',
            '\x2', 't', 'u', '\x5', '\x2',
            '\x2', '\x2', 'u', '\x8D', '\x3',
            '\x2', '\x2', '\x2', 'v', 'w',
            '\f', '\b', '\x2', '\x2', 'w',
            'x', '\a', ' ', '\x2', '\x2',
            'x', 'y', '\x5', '(', '\x15',
            '\x2', 'y', 'z', '\a', '!',
            '\x2', '\x2', 'z', '\x8C', '\x3',
            '\x2', '\x2', '\x2', '{', '|',
            '\f', '\a', '\x2', '\x2', '|',
            '~', '\a', '\x1E', '\x2', '\x2',
            '}', '\x7F', '\x5', '\x6', '\x4',
            '\x2', '~', '}', '\x3', '\x2',
            '\x2', '\x2', '~', '\x7F', '\x3',
            '\x2', '\x2', '\x2', '\x7F', '\x80',
            '\x3', '\x2', '\x2', '\x2', '\x80',
            '\x8C', '\a', '\x1F', '\x2', '\x2',
            '\x81', '\x82', '\f', '\x6', '\x2',
            '\x2', '\x82', '\x83', '\a', 'J',
            '\x2', '\x2', '\x83', '\x8C', '\a',
            'O', '\x2', '\x2', '\x84', '\x85',
            '\f', '\x5', '\x2', '\x2', '\x85',
            '\x86', '\a', 'I', '\x2', '\x2',
            '\x86', '\x8C', '\a', 'O', '\x2',
            '\x2', '\x87', '\x88', '\f', '\x4',
            '\x2', '\x2', '\x88', '\x8C', '\a',
            '+', '\x2', '\x2', '\x89', '\x8A',
            '\f', '\x3', '\x2', '\x2', '\x8A',
            '\x8C', '\a', '-', '\x2', '\x2',
            '\x8B', 'v', '\x3', '\x2', '\x2',
            '\x2', '\x8B', '{', '\x3', '\x2',
            '\x2', '\x2', '\x8B', '\x81', '\x3',
            '\x2', '\x2', '\x2', '\x8B', '\x84',
            '\x3', '\x2', '\x2', '\x2', '\x8B',
            '\x87', '\x3', '\x2', '\x2', '\x2',
            '\x8B', '\x89', '\x3', '\x2', '\x2',
            '\x2', '\x8C', '\x8F', '\x3', '\x2',
            '\x2', '\x2', '\x8D', '\x8B', '\x3',
            '\x2', '\x2', '\x2', '\x8D', '\x8E',
            '\x3', '\x2', '\x2', '\x2', '\x8E',
            '\x5', '\x3', '\x2', '\x2', '\x2',
            '\x8F', '\x8D', '\x3', '\x2', '\x2',
            '\x2', '\x90', '\x91', '\b', '\x4',
            '\x1', '\x2', '\x91', '\x92', '\x5',
            '$', '\x13', '\x2', '\x92', '\x98',
            '\x3', '\x2', '\x2', '\x2', '\x93',
            '\x94', '\f', '\x3', '\x2', '\x2',
            '\x94', '\x95', '\a', ';', '\x2',
            '\x2', '\x95', '\x97', '\x5', '$',
            '\x13', '\x2', '\x96', '\x93', '\x3',
            '\x2', '\x2', '\x2', '\x97', '\x9A',
            '\x3', '\x2', '\x2', '\x2', '\x98',
            '\x96', '\x3', '\x2', '\x2', '\x2',
            '\x98', '\x99', '\x3', '\x2', '\x2',
            '\x2', '\x99', '\a', '\x3', '\x2',
            '\x2', '\x2', '\x9A', '\x98', '\x3',
            '\x2', '\x2', '\x2', '\x9B', '\xAB',
            '\x5', '\x4', '\x3', '\x2', '\x9C',
            '\x9D', '\a', '+', '\x2', '\x2',
            '\x9D', '\xAB', '\x5', '\b', '\x5',
            '\x2', '\x9E', '\x9F', '\a', '-',
            '\x2', '\x2', '\x9F', '\xAB', '\x5',
            '\b', '\x5', '\x2', '\xA0', '\xA1',
            '\x5', '\n', '\x6', '\x2', '\xA1',
            '\xA2', '\x5', '\f', '\a', '\x2',
            '\xA2', '\xAB', '\x3', '\x2', '\x2',
            '\x2', '\xA3', '\xA4', '\a', '\x1A',
            '\x2', '\x2', '\xA4', '\xAB', '\x5',
            '\b', '\x5', '\x2', '\xA5', '\xA6',
            '\a', '\x1A', '\x2', '\x2', '\xA6',
            '\xA7', '\a', '\x1E', '\x2', '\x2',
            '\xA7', '\xA8', '\x5', ',', '\x17',
            '\x2', '\xA8', '\xA9', '\a', '\x1F',
            '\x2', '\x2', '\xA9', '\xAB', '\x3',
            '\x2', '\x2', '\x2', '\xAA', '\x9B',
            '\x3', '\x2', '\x2', '\x2', '\xAA',
            '\x9C', '\x3', '\x2', '\x2', '\x2',
            '\xAA', '\x9E', '\x3', '\x2', '\x2',
            '\x2', '\xAA', '\xA0', '\x3', '\x2',
            '\x2', '\x2', '\xAA', '\xA3', '\x3',
            '\x2', '\x2', '\x2', '\xAA', '\xA5',
            '\x3', '\x2', '\x2', '\x2', '\xAB',
            '\t', '\x3', '\x2', '\x2', '\x2',
            '\xAC', '\xAD', '\t', '\x2', '\x2',
            '\x2', '\xAD', '\v', '\x3', '\x2',
            '\x2', '\x2', '\xAE', '\xAF', '\a',
            '\x1E', '\x2', '\x2', '\xAF', '\xB0',
            '\x5', ',', '\x17', '\x2', '\xB0',
            '\xB1', '\a', '\x1F', '\x2', '\x2',
            '\xB1', '\xB2', '\x5', '\f', '\a',
            '\x2', '\xB2', '\xB5', '\x3', '\x2',
            '\x2', '\x2', '\xB3', '\xB5', '\x5',
            '\b', '\x5', '\x2', '\xB4', '\xAE',
            '\x3', '\x2', '\x2', '\x2', '\xB4',
            '\xB3', '\x3', '\x2', '\x2', '\x2',
            '\xB5', '\r', '\x3', '\x2', '\x2',
            '\x2', '\xB6', '\xB7', '\b', '\b',
            '\x1', '\x2', '\xB7', '\xB8', '\x5',
            '\f', '\a', '\x2', '\xB8', '\xC4',
            '\x3', '\x2', '\x2', '\x2', '\xB9',
            '\xBA', '\f', '\x5', '\x2', '\x2',
            '\xBA', '\xBB', '\a', '.', '\x2',
            '\x2', '\xBB', '\xC3', '\x5', '\f',
            '\a', '\x2', '\xBC', '\xBD', '\f',
            '\x4', '\x2', '\x2', '\xBD', '\xBE',
            '\a', '/', '\x2', '\x2', '\xBE',
            '\xC3', '\x5', '\f', '\a', '\x2',
            '\xBF', '\xC0', '\f', '\x3', '\x2',
            '\x2', '\xC0', '\xC1', '\a', '\x30',
            '\x2', '\x2', '\xC1', '\xC3', '\x5',
            '\f', '\a', '\x2', '\xC2', '\xB9',
            '\x3', '\x2', '\x2', '\x2', '\xC2',
            '\xBC', '\x3', '\x2', '\x2', '\x2',
            '\xC2', '\xBF', '\x3', '\x2', '\x2',
            '\x2', '\xC3', '\xC6', '\x3', '\x2',
            '\x2', '\x2', '\xC4', '\xC2', '\x3',
            '\x2', '\x2', '\x2', '\xC4', '\xC5',
            '\x3', '\x2', '\x2', '\x2', '\xC5',
            '\xF', '\x3', '\x2', '\x2', '\x2',
            '\xC6', '\xC4', '\x3', '\x2', '\x2',
            '\x2', '\xC7', '\xC8', '\b', '\t',
            '\x1', '\x2', '\xC8', '\xC9', '\x5',
            '\xE', '\b', '\x2', '\xC9', '\xD2',
            '\x3', '\x2', '\x2', '\x2', '\xCA',
            '\xCB', '\f', '\x4', '\x2', '\x2',
            '\xCB', '\xCC', '\a', '*', '\x2',
            '\x2', '\xCC', '\xD1', '\x5', '\xE',
            '\b', '\x2', '\xCD', '\xCE', '\f',
            '\x3', '\x2', '\x2', '\xCE', '\xCF',
            '\a', ',', '\x2', '\x2', '\xCF',
            '\xD1', '\x5', '\xE', '\b', '\x2',
            '\xD0', '\xCA', '\x3', '\x2', '\x2',
            '\x2', '\xD0', '\xCD', '\x3', '\x2',
            '\x2', '\x2', '\xD1', '\xD4', '\x3',
            '\x2', '\x2', '\x2', '\xD2', '\xD0',
            '\x3', '\x2', '\x2', '\x2', '\xD2',
            '\xD3', '\x3', '\x2', '\x2', '\x2',
            '\xD3', '\x11', '\x3', '\x2', '\x2',
            '\x2', '\xD4', '\xD2', '\x3', '\x2',
            '\x2', '\x2', '\xD5', '\xD6', '\b',
            '\n', '\x1', '\x2', '\xD6', '\xD7',
            '\x5', '\x10', '\t', '\x2', '\xD7',
            '\xE0', '\x3', '\x2', '\x2', '\x2',
            '\xD8', '\xD9', '\f', '\x4', '\x2',
            '\x2', '\xD9', '\xDA', '\a', '(',
            '\x2', '\x2', '\xDA', '\xDF', '\x5',
            '\x10', '\t', '\x2', '\xDB', '\xDC',
            '\f', '\x3', '\x2', '\x2', '\xDC',
            '\xDD', '\a', ')', '\x2', '\x2',
            '\xDD', '\xDF', '\x5', '\x10', '\t',
            '\x2', '\xDE', '\xD8', '\x3', '\x2',
            '\x2', '\x2', '\xDE', '\xDB', '\x3',
            '\x2', '\x2', '\x2', '\xDF', '\xE2',
            '\x3', '\x2', '\x2', '\x2', '\xE0',
            '\xDE', '\x3', '\x2', '\x2', '\x2',
            '\xE0', '\xE1', '\x3', '\x2', '\x2',
            '\x2', '\xE1', '\x13', '\x3', '\x2',
            '\x2', '\x2', '\xE2', '\xE0', '\x3',
            '\x2', '\x2', '\x2', '\xE3', '\xE4',
            '\b', '\v', '\x1', '\x2', '\xE4',
            '\xE5', '\x5', '\x12', '\n', '\x2',
            '\xE5', '\xF4', '\x3', '\x2', '\x2',
            '\x2', '\xE6', '\xE7', '\f', '\x6',
            '\x2', '\x2', '\xE7', '\xE8', '\a',
            '$', '\x2', '\x2', '\xE8', '\xF3',
            '\x5', '\x12', '\n', '\x2', '\xE9',
            '\xEA', '\f', '\x5', '\x2', '\x2',
            '\xEA', '\xEB', '\a', '&', '\x2',
            '\x2', '\xEB', '\xF3', '\x5', '\x12',
            '\n', '\x2', '\xEC', '\xED', '\f',
            '\x4', '\x2', '\x2', '\xED', '\xEE',
            '\a', '%', '\x2', '\x2', '\xEE',
            '\xF3', '\x5', '\x12', '\n', '\x2',
            '\xEF', '\xF0', '\f', '\x3', '\x2',
            '\x2', '\xF0', '\xF1', '\a', '\'',
            '\x2', '\x2', '\xF1', '\xF3', '\x5',
            '\x12', '\n', '\x2', '\xF2', '\xE6',
            '\x3', '\x2', '\x2', '\x2', '\xF2',
            '\xE9', '\x3', '\x2', '\x2', '\x2',
            '\xF2', '\xEC', '\x3', '\x2', '\x2',
            '\x2', '\xF2', '\xEF', '\x3', '\x2',
            '\x2', '\x2', '\xF3', '\xF6', '\x3',
            '\x2', '\x2', '\x2', '\xF4', '\xF2',
            '\x3', '\x2', '\x2', '\x2', '\xF4',
            '\xF5', '\x3', '\x2', '\x2', '\x2',
            '\xF5', '\x15', '\x3', '\x2', '\x2',
            '\x2', '\xF6', '\xF4', '\x3', '\x2',
            '\x2', '\x2', '\xF7', '\xF8', '\b',
            '\f', '\x1', '\x2', '\xF8', '\xF9',
            '\x5', '\x14', '\v', '\x2', '\xF9',
            '\x102', '\x3', '\x2', '\x2', '\x2',
            '\xFA', '\xFB', '\f', '\x4', '\x2',
            '\x2', '\xFB', '\xFC', '\a', 'G',
            '\x2', '\x2', '\xFC', '\x101', '\x5',
            '\x14', '\v', '\x2', '\xFD', '\xFE',
            '\f', '\x3', '\x2', '\x2', '\xFE',
            '\xFF', '\a', 'H', '\x2', '\x2',
            '\xFF', '\x101', '\x5', '\x14', '\v',
            '\x2', '\x100', '\xFA', '\x3', '\x2',
            '\x2', '\x2', '\x100', '\xFD', '\x3',
            '\x2', '\x2', '\x2', '\x101', '\x104',
            '\x3', '\x2', '\x2', '\x2', '\x102',
            '\x100', '\x3', '\x2', '\x2', '\x2',
            '\x102', '\x103', '\x3', '\x2', '\x2',
            '\x2', '\x103', '\x17', '\x3', '\x2',
            '\x2', '\x2', '\x104', '\x102', '\x3',
            '\x2', '\x2', '\x2', '\x105', '\x106',
            '\b', '\r', '\x1', '\x2', '\x106',
            '\x107', '\x5', '\x16', '\f', '\x2',
            '\x107', '\x10D', '\x3', '\x2', '\x2',
            '\x2', '\x108', '\x109', '\f', '\x3',
            '\x2', '\x2', '\x109', '\x10A', '\a',
            '\x31', '\x2', '\x2', '\x10A', '\x10C',
            '\x5', '\x16', '\f', '\x2', '\x10B',
            '\x108', '\x3', '\x2', '\x2', '\x2',
            '\x10C', '\x10F', '\x3', '\x2', '\x2',
            '\x2', '\x10D', '\x10B', '\x3', '\x2',
            '\x2', '\x2', '\x10D', '\x10E', '\x3',
            '\x2', '\x2', '\x2', '\x10E', '\x19',
            '\x3', '\x2', '\x2', '\x2', '\x10F',
            '\x10D', '\x3', '\x2', '\x2', '\x2',
            '\x110', '\x111', '\b', '\xE', '\x1',
            '\x2', '\x111', '\x112', '\x5', '\x18',
            '\r', '\x2', '\x112', '\x118', '\x3',
            '\x2', '\x2', '\x2', '\x113', '\x114',
            '\f', '\x3', '\x2', '\x2', '\x114',
            '\x115', '\a', '\x35', '\x2', '\x2',
            '\x115', '\x117', '\x5', '\x18', '\r',
            '\x2', '\x116', '\x113', '\x3', '\x2',
            '\x2', '\x2', '\x117', '\x11A', '\x3',
            '\x2', '\x2', '\x2', '\x118', '\x116',
            '\x3', '\x2', '\x2', '\x2', '\x118',
            '\x119', '\x3', '\x2', '\x2', '\x2',
            '\x119', '\x1B', '\x3', '\x2', '\x2',
            '\x2', '\x11A', '\x118', '\x3', '\x2',
            '\x2', '\x2', '\x11B', '\x11C', '\b',
            '\xF', '\x1', '\x2', '\x11C', '\x11D',
            '\x5', '\x1A', '\xE', '\x2', '\x11D',
            '\x123', '\x3', '\x2', '\x2', '\x2',
            '\x11E', '\x11F', '\f', '\x3', '\x2',
            '\x2', '\x11F', '\x120', '\a', '\x32',
            '\x2', '\x2', '\x120', '\x122', '\x5',
            '\x1A', '\xE', '\x2', '\x121', '\x11E',
            '\x3', '\x2', '\x2', '\x2', '\x122',
            '\x125', '\x3', '\x2', '\x2', '\x2',
            '\x123', '\x121', '\x3', '\x2', '\x2',
            '\x2', '\x123', '\x124', '\x3', '\x2',
            '\x2', '\x2', '\x124', '\x1D', '\x3',
            '\x2', '\x2', '\x2', '\x125', '\x123',
            '\x3', '\x2', '\x2', '\x2', '\x126',
            '\x127', '\b', '\x10', '\x1', '\x2',
            '\x127', '\x128', '\x5', '\x1C', '\xF',
            '\x2', '\x128', '\x12E', '\x3', '\x2',
            '\x2', '\x2', '\x129', '\x12A', '\f',
            '\x3', '\x2', '\x2', '\x12A', '\x12B',
            '\a', '\x33', '\x2', '\x2', '\x12B',
            '\x12D', '\x5', '\x1C', '\xF', '\x2',
            '\x12C', '\x129', '\x3', '\x2', '\x2',
            '\x2', '\x12D', '\x130', '\x3', '\x2',
            '\x2', '\x2', '\x12E', '\x12C', '\x3',
            '\x2', '\x2', '\x2', '\x12E', '\x12F',
            '\x3', '\x2', '\x2', '\x2', '\x12F',
            '\x1F', '\x3', '\x2', '\x2', '\x2',
            '\x130', '\x12E', '\x3', '\x2', '\x2',
            '\x2', '\x131', '\x132', '\b', '\x11',
            '\x1', '\x2', '\x132', '\x133', '\x5',
            '\x1E', '\x10', '\x2', '\x133', '\x139',
            '\x3', '\x2', '\x2', '\x2', '\x134',
            '\x135', '\f', '\x3', '\x2', '\x2',
            '\x135', '\x136', '\a', '\x34', '\x2',
            '\x2', '\x136', '\x138', '\x5', '\x1E',
            '\x10', '\x2', '\x137', '\x134', '\x3',
            '\x2', '\x2', '\x2', '\x138', '\x13B',
            '\x3', '\x2', '\x2', '\x2', '\x139',
            '\x137', '\x3', '\x2', '\x2', '\x2',
            '\x139', '\x13A', '\x3', '\x2', '\x2',
            '\x2', '\x13A', '!', '\x3', '\x2',
            '\x2', '\x2', '\x13B', '\x139', '\x3',
            '\x2', '\x2', '\x2', '\x13C', '\x142',
            '\x5', ' ', '\x11', '\x2', '\x13D',
            '\x13E', '\a', '\x38', '\x2', '\x2',
            '\x13E', '\x13F', '\x5', '(', '\x15',
            '\x2', '\x13F', '\x140', '\a', '\x39',
            '\x2', '\x2', '\x140', '\x141', '\x5',
            '\"', '\x12', '\x2', '\x141', '\x143',
            '\x3', '\x2', '\x2', '\x2', '\x142',
            '\x13D', '\x3', '\x2', '\x2', '\x2',
            '\x142', '\x143', '\x3', '\x2', '\x2',
            '\x2', '\x143', '#', '\x3', '\x2',
            '\x2', '\x2', '\x144', '\x14A', '\x5',
            '\"', '\x12', '\x2', '\x145', '\x146',
            '\x5', '\b', '\x5', '\x2', '\x146',
            '\x147', '\x5', '&', '\x14', '\x2',
            '\x147', '\x148', '\x5', '$', '\x13',
            '\x2', '\x148', '\x14A', '\x3', '\x2',
            '\x2', '\x2', '\x149', '\x144', '\x3',
            '\x2', '\x2', '\x2', '\x149', '\x145',
            '\x3', '\x2', '\x2', '\x2', '\x14A',
            '%', '\x3', '\x2', '\x2', '\x2',
            '\x14B', '\x14C', '\t', '\x3', '\x2',
            '\x2', '\x14C', '\'', '\x3', '\x2',
            '\x2', '\x2', '\x14D', '\x14E', '\x5',
            '$', '\x13', '\x2', '\x14E', ')',
            '\x3', '\x2', '\x2', '\x2', '\x14F',
            '\x150', '\x5', '\"', '\x12', '\x2',
            '\x150', '+', '\x3', '\x2', '\x2',
            '\x2', '\x151', '\x153', '\a', 'O',
            '\x2', '\x2', '\x152', '\x154', '\x5',
            '\x34', '\x1B', '\x2', '\x153', '\x152',
            '\x3', '\x2', '\x2', '\x2', '\x153',
            '\x154', '\x3', '\x2', '\x2', '\x2',
            '\x154', '\x15E', '\x3', '\x2', '\x2',
            '\x2', '\x155', '\x157', '\x5', '.',
            '\x18', '\x2', '\x156', '\x158', '\x5',
            '\x34', '\x1B', '\x2', '\x157', '\x156',
            '\x3', '\x2', '\x2', '\x2', '\x157',
            '\x158', '\x3', '\x2', '\x2', '\x2',
            '\x158', '\x15E', '\x3', '\x2', '\x2',
            '\x2', '\x159', '\x15B', '\x5', '\x32',
            '\x1A', '\x2', '\x15A', '\x15C', '\x5',
            '\x34', '\x1B', '\x2', '\x15B', '\x15A',
            '\x3', '\x2', '\x2', '\x2', '\x15B',
            '\x15C', '\x3', '\x2', '\x2', '\x2',
            '\x15C', '\x15E', '\x3', '\x2', '\x2',
            '\x2', '\x15D', '\x151', '\x3', '\x2',
            '\x2', '\x2', '\x15D', '\x155', '\x3',
            '\x2', '\x2', '\x2', '\x15D', '\x159',
            '\x3', '\x2', '\x2', '\x2', '\x15E',
            '-', '\x3', '\x2', '\x2', '\x2',
            '\x15F', '\x160', '\a', '\x3', '\x2',
            '\x2', '\x160', '\x161', '\x5', '\x30',
            '\x19', '\x2', '\x161', '\x162', '\a',
            '&', '\x2', '\x2', '\x162', '/',
            '\x3', '\x2', '\x2', '\x2', '\x163',
            '\x169', '\x5', ',', '\x17', '\x2',
            '\x164', '\x165', '\x5', ',', '\x17',
            '\x2', '\x165', '\x166', '\a', ';',
            '\x2', '\x2', '\x166', '\x167', '\x5',
            '\x30', '\x19', '\x2', '\x167', '\x169',
            '\x3', '\x2', '\x2', '\x2', '\x168',
            '\x163', '\x3', '\x2', '\x2', '\x2',
            '\x168', '\x164', '\x3', '\x2', '\x2',
            '\x2', '\x169', '\x31', '\x3', '\x2',
            '\x2', '\x2', '\x16A', '\x16B', '\t',
            '\x4', '\x2', '\x2', '\x16B', '\x33',
            '\x3', '\x2', '\x2', '\x2', '\x16C',
            '\x16E', '\a', '.', '\x2', '\x2',
            '\x16D', '\x16C', '\x3', '\x2', '\x2',
            '\x2', '\x16E', '\x16F', '\x3', '\x2',
            '\x2', '\x2', '\x16F', '\x16D', '\x3',
            '\x2', '\x2', '\x2', '\x16F', '\x170',
            '\x3', '\x2', '\x2', '\x2', '\x170',
            '\x35', '\x3', '\x2', '\x2', '\x2',
            '\x171', '\x172', '\x5', ',', '\x17',
            '\x2', '\x172', '\x173', '\a', 'O',
            '\x2', '\x2', '\x173', '\x174', '\a',
            ':', '\x2', '\x2', '\x174', '\x179',
            '\x3', '\x2', '\x2', '\x2', '\x175',
            '\x176', '\x5', '\x38', '\x1D', '\x2',
            '\x176', '\x177', '\a', ':', '\x2',
            '\x2', '\x177', '\x179', '\x3', '\x2',
            '\x2', '\x2', '\x178', '\x171', '\x3',
            '\x2', '\x2', '\x2', '\x178', '\x175',
            '\x3', '\x2', '\x2', '\x2', '\x179',
            '\x37', '\x3', '\x2', '\x2', '\x2',
            '\x17A', '\x17B', '\x5', ',', '\x17',
            '\x2', '\x17B', '\x17C', '\a', 'O',
            '\x2', '\x2', '\x17C', '\x17D', '\a',
            '<', '\x2', '\x2', '\x17D', '\x17E',
            '\x5', '(', '\x15', '\x2', '\x17E',
            '\x17F', '\a', ':', '\x2', '\x2',
            '\x17F', '\x39', '\x3', '\x2', '\x2',
            '\x2', '\x180', '\x181', '\a', '\x1B',
            '\x2', '\x2', '\x181', '\x182', '\a',
            'O', '\x2', '\x2', '\x182', '\x184',
            '\a', '\"', '\x2', '\x2', '\x183',
            '\x185', '\x5', '<', '\x1F', '\x2',
            '\x184', '\x183', '\x3', '\x2', '\x2',
            '\x2', '\x185', '\x186', '\x3', '\x2',
            '\x2', '\x2', '\x186', '\x184', '\x3',
            '\x2', '\x2', '\x2', '\x186', '\x187',
            '\x3', '\x2', '\x2', '\x2', '\x187',
            '\x188', '\x3', '\x2', '\x2', '\x2',
            '\x188', '\x189', '\a', '#', '\x2',
            '\x2', '\x189', ';', '\x3', '\x2',
            '\x2', '\x2', '\x18A', '\x18B', '\x5',
            ',', '\x17', '\x2', '\x18B', '\x18D',
            '\a', 'O', '\x2', '\x2', '\x18C',
            '\x18E', '\x5', '>', ' ', '\x2',
            '\x18D', '\x18C', '\x3', '\x2', '\x2',
            '\x2', '\x18D', '\x18E', '\x3', '\x2',
            '\x2', '\x2', '\x18E', '\x18F', '\x3',
            '\x2', '\x2', '\x2', '\x18F', '\x190',
            '\a', ':', '\x2', '\x2', '\x190',
            '=', '\x3', '\x2', '\x2', '\x2',
            '\x191', '\x192', '\a', ' ', '\x2',
            '\x2', '\x192', '\x193', '\a', 'K',
            '\x2', '\x2', '\x193', '\x194', '\a',
            '!', '\x2', '\x2', '\x194', '?',
            '\x3', '\x2', '\x2', '\x2', '\x195',
            '\x196', '\a', '\x13', '\x2', '\x2',
            '\x196', '\x19A', '\x5', '\x36', '\x1C',
            '\x2', '\x197', '\x198', '\a', '\x13',
            '\x2', '\x2', '\x198', '\x19A', '\x5',
            '\x38', '\x1D', '\x2', '\x199', '\x195',
            '\x3', '\x2', '\x2', '\x2', '\x199',
            '\x197', '\x3', '\x2', '\x2', '\x2',
            '\x19A', '\x41', '\x3', '\x2', '\x2',
            '\x2', '\x19B', '\x19C', '\x5', ',',
            '\x17', '\x2', '\x19C', '\x19D', '\a',
            'O', '\x2', '\x2', '\x19D', '\x19F',
            '\a', '\x1E', '\x2', '\x2', '\x19E',
            '\x1A0', '\x5', '\x44', '#', '\x2',
            '\x19F', '\x19E', '\x3', '\x2', '\x2',
            '\x2', '\x19F', '\x1A0', '\x3', '\x2',
            '\x2', '\x2', '\x1A0', '\x1A1', '\x3',
            '\x2', '\x2', '\x2', '\x1A1', '\x1A2',
            '\a', '\x1F', '\x2', '\x2', '\x1A2',
            '\x1A6', '\a', '\"', '\x2', '\x2',
            '\x1A3', '\x1A5', '\x5', 'H', '%',
            '\x2', '\x1A4', '\x1A3', '\x3', '\x2',
            '\x2', '\x2', '\x1A5', '\x1A8', '\x3',
            '\x2', '\x2', '\x2', '\x1A6', '\x1A4',
            '\x3', '\x2', '\x2', '\x2', '\x1A6',
            '\x1A7', '\x3', '\x2', '\x2', '\x2',
            '\x1A7', '\x1A9', '\x3', '\x2', '\x2',
            '\x2', '\x1A8', '\x1A6', '\x3', '\x2',
            '\x2', '\x2', '\x1A9', '\x1AA', '\a',
            '#', '\x2', '\x2', '\x1AA', '\x43',
            '\x3', '\x2', '\x2', '\x2', '\x1AB',
            '\x1B1', '\x5', '\x46', '$', '\x2',
            '\x1AC', '\x1AD', '\x5', '\x46', '$',
            '\x2', '\x1AD', '\x1AE', '\a', ';',
            '\x2', '\x2', '\x1AE', '\x1AF', '\x5',
            '\x44', '#', '\x2', '\x1AF', '\x1B1',
            '\x3', '\x2', '\x2', '\x2', '\x1B0',
            '\x1AB', '\x3', '\x2', '\x2', '\x2',
            '\x1B0', '\x1AC', '\x3', '\x2', '\x2',
            '\x2', '\x1B1', '\x45', '\x3', '\x2',
            '\x2', '\x2', '\x1B2', '\x1B3', '\x5',
            ',', '\x17', '\x2', '\x1B3', '\x1B4',
            '\a', 'O', '\x2', '\x2', '\x1B4',
            'G', '\x3', '\x2', '\x2', '\x2',
            '\x1B5', '\x1C2', '\x5', 'J', '&',
            '\x2', '\x1B6', '\x1C2', '\x5', 'L',
            '\'', '\x2', '\x1B7', '\x1C2', '\x5',
            'N', '(', '\x2', '\x1B8', '\x1C2',
            '\x5', 'P', ')', '\x2', '\x1B9',
            '\x1C2', '\x5', 'T', '+', '\x2',
            '\x1BA', '\x1C2', '\x5', 'V', ',',
            '\x2', '\x1BB', '\x1C2', '\x5', 'X',
            '-', '\x2', '\x1BC', '\x1C2', '\x5',
            'Z', '.', '\x2', '\x1BD', '\x1C2',
            '\x5', '\\', '/', '\x2', '\x1BE',
            '\x1C2', '\x5', '\x36', '\x1C', '\x2',
            '\x1BF', '\x1C2', '\x5', '\x38', '\x1D',
            '\x2', '\x1C0', '\x1C2', '\x5', '\x64',
            '\x33', '\x2', '\x1C1', '\x1B5', '\x3',
            '\x2', '\x2', '\x2', '\x1C1', '\x1B6',
            '\x3', '\x2', '\x2', '\x2', '\x1C1',
            '\x1B7', '\x3', '\x2', '\x2', '\x2',
            '\x1C1', '\x1B8', '\x3', '\x2', '\x2',
            '\x2', '\x1C1', '\x1B9', '\x3', '\x2',
            '\x2', '\x2', '\x1C1', '\x1BA', '\x3',
            '\x2', '\x2', '\x2', '\x1C1', '\x1BB',
            '\x3', '\x2', '\x2', '\x2', '\x1C1',
            '\x1BC', '\x3', '\x2', '\x2', '\x2',
            '\x1C1', '\x1BD', '\x3', '\x2', '\x2',
            '\x2', '\x1C1', '\x1BE', '\x3', '\x2',
            '\x2', '\x2', '\x1C1', '\x1BF', '\x3',
            '\x2', '\x2', '\x2', '\x1C1', '\x1C0',
            '\x3', '\x2', '\x2', '\x2', '\x1C2',
            'I', '\x3', '\x2', '\x2', '\x2',
            '\x1C3', '\x1C7', '\a', '\"', '\x2',
            '\x2', '\x1C4', '\x1C6', '\x5', 'H',
            '%', '\x2', '\x1C5', '\x1C4', '\x3',
            '\x2', '\x2', '\x2', '\x1C6', '\x1C9',
            '\x3', '\x2', '\x2', '\x2', '\x1C7',
            '\x1C5', '\x3', '\x2', '\x2', '\x2',
            '\x1C7', '\x1C8', '\x3', '\x2', '\x2',
            '\x2', '\x1C8', '\x1CA', '\x3', '\x2',
            '\x2', '\x2', '\x1C9', '\x1C7', '\x3',
            '\x2', '\x2', '\x2', '\x1CA', '\x1CB',
            '\a', '#', '\x2', '\x2', '\x1CB',
            'K', '\x3', '\x2', '\x2', '\x2',
            '\x1CC', '\x1CD', '\a', '\v', '\x2',
            '\x2', '\x1CD', '\x1CE', '\a', ':',
            '\x2', '\x2', '\x1CE', 'M', '\x3',
            '\x2', '\x2', '\x2', '\x1CF', '\x1D0',
            '\a', '\x15', '\x2', '\x2', '\x1D0',
            '\x1D1', '\a', '\x1E', '\x2', '\x2',
            '\x1D1', '\x1D2', '\x5', '(', '\x15',
            '\x2', '\x1D2', '\x1D3', '\a', '\x1F',
            '\x2', '\x2', '\x1D3', '\x1D5', '\x5',
            'H', '%', '\x2', '\x1D4', '\x1D6',
            '\x5', 'R', '*', '\x2', '\x1D5',
            '\x1D4', '\x3', '\x2', '\x2', '\x2',
            '\x1D5', '\x1D6', '\x3', '\x2', '\x2',
            '\x2', '\x1D6', 'O', '\x3', '\x2',
            '\x2', '\x2', '\x1D7', '\x1D8', '\a',
            '\r', '\x2', '\x2', '\x1D8', '\x1D9',
            '\a', ':', '\x2', '\x2', '\x1D9',
            'Q', '\x3', '\x2', '\x2', '\x2',
            '\x1DA', '\x1DB', '\a', '\x11', '\x2',
            '\x2', '\x1DB', '\x1DC', '\x5', 'H',
            '%', '\x2', '\x1DC', 'S', '\x3',
            '\x2', '\x2', '\x2', '\x1DD', '\x1DE',
            '\a', '\xF', '\x2', '\x2', '\x1DE',
            '\x1DF', '\x5', 'H', '%', '\x2',
            '\x1DF', '\x1E0', '\a', '\x1D', '\x2',
            '\x2', '\x1E0', '\x1E1', '\a', '\x1E',
            '\x2', '\x2', '\x1E1', '\x1E2', '\x5',
            '(', '\x15', '\x2', '\x1E2', '\x1E3',
            '\a', '\x1F', '\x2', '\x2', '\x1E3',
            '\x1E4', '\a', ':', '\x2', '\x2',
            '\x1E4', 'U', '\x3', '\x2', '\x2',
            '\x2', '\x1E5', '\x1E6', '\x5', '(',
            '\x15', '\x2', '\x1E6', '\x1E7', '\a',
            ':', '\x2', '\x2', '\x1E7', 'W',
            '\x3', '\x2', '\x2', '\x2', '\x1E8',
            '\x1E9', '\a', '\x14', '\x2', '\x2',
            '\x1E9', '\x1EA', '\a', '\x1E', '\x2',
            '\x2', '\x1EA', '\x1EB', '\x5', '(',
            '\x15', '\x2', '\x1EB', '\x1EC', '\a',
            ':', '\x2', '\x2', '\x1EC', '\x1ED',
            '\x5', '(', '\x15', '\x2', '\x1ED',
            '\x1EE', '\a', ':', '\x2', '\x2',
            '\x1EE', '\x1EF', '\x5', '(', '\x15',
            '\x2', '\x1EF', '\x1F0', '\a', ':',
            '\x2', '\x2', '\x1F0', '\x1F1', '\a',
            '\x1F', '\x2', '\x2', '\x1F1', '\x1F2',
            '\x5', 'H', '%', '\x2', '\x1F2',
            'Y', '\x3', '\x2', '\x2', '\x2',
            '\x1F3', '\x1F4', '\a', '\x18', '\x2',
            '\x2', '\x1F4', '\x1FA', '\a', ':',
            '\x2', '\x2', '\x1F5', '\x1F6', '\a',
            '\x18', '\x2', '\x2', '\x1F6', '\x1F7',
            '\x5', '(', '\x15', '\x2', '\x1F7',
            '\x1F8', '\a', ':', '\x2', '\x2',
            '\x1F8', '\x1FA', '\x3', '\x2', '\x2',
            '\x2', '\x1F9', '\x1F3', '\x3', '\x2',
            '\x2', '\x2', '\x1F9', '\x1F5', '\x3',
            '\x2', '\x2', '\x2', '\x1FA', '[',
            '\x3', '\x2', '\x2', '\x2', '\x1FB',
            '\x1FC', '\a', '\t', '\x2', '\x2',
            '\x1FC', '\x1FD', '\a', '\x1E', '\x2',
            '\x2', '\x1FD', '\x1FE', '\x5', '(',
            '\x15', '\x2', '\x1FE', '\x1FF', '\a',
            '\x1F', '\x2', '\x2', '\x1FF', '\x201',
            '\a', '\"', '\x2', '\x2', '\x200',
            '\x202', '\x5', '^', '\x30', '\x2',
            '\x201', '\x200', '\x3', '\x2', '\x2',
            '\x2', '\x202', '\x203', '\x3', '\x2',
            '\x2', '\x2', '\x203', '\x201', '\x3',
            '\x2', '\x2', '\x2', '\x203', '\x204',
            '\x3', '\x2', '\x2', '\x2', '\x204',
            '\x205', '\x3', '\x2', '\x2', '\x2',
            '\x205', '\x206', '\a', '#', '\x2',
            '\x2', '\x206', ']', '\x3', '\x2',
            '\x2', '\x2', '\x207', '\x20A', '\x5',
            '`', '\x31', '\x2', '\x208', '\x20A',
            '\x5', '\x62', '\x32', '\x2', '\x209',
            '\x207', '\x3', '\x2', '\x2', '\x2',
            '\x209', '\x208', '\x3', '\x2', '\x2',
            '\x2', '\x20A', '_', '\x3', '\x2',
            '\x2', '\x2', '\x20B', '\x20C', '\a',
            '\f', '\x2', '\x2', '\x20C', '\x20D',
            '\a', 'K', '\x2', '\x2', '\x20D',
            '\x20E', '\a', '\x39', '\x2', '\x2',
            '\x20E', '\x214', '\x5', 'H', '%',
            '\x2', '\x20F', '\x210', '\a', '\f',
            '\x2', '\x2', '\x210', '\x211', '\a',
            'N', '\x2', '\x2', '\x211', '\x212',
            '\a', '\x39', '\x2', '\x2', '\x212',
            '\x214', '\x5', 'H', '%', '\x2',
            '\x213', '\x20B', '\x3', '\x2', '\x2',
            '\x2', '\x213', '\x20F', '\x3', '\x2',
            '\x2', '\x2', '\x214', '\x61', '\x3',
            '\x2', '\x2', '\x2', '\x215', '\x216',
            '\a', '\xE', '\x2', '\x2', '\x216',
            '\x217', '\a', '\x39', '\x2', '\x2',
            '\x217', '\x218', '\x5', 'H', '%',
            '\x2', '\x218', '\x63', '\x3', '\x2',
            '\x2', '\x2', '\x219', '\x21A', '\a',
            '\x1D', '\x2', '\x2', '\x21A', '\x21B',
            '\a', '\x1E', '\x2', '\x2', '\x21B',
            '\x21C', '\x5', '(', '\x15', '\x2',
            '\x21C', '\x21D', '\a', '\x1F', '\x2',
            '\x2', '\x21D', '\x21E', '\x5', 'H',
            '%', '\x2', '\x21E', '\x65', '\x3',
            '\x2', '\x2', '\x2', '\x21F', '\x220',
            '\t', '\x5', '\x2', '\x2', '\x220',
            'g', '\x3', '\x2', '\x2', '\x2',
            '\x221', '\x225', '\x5', ':', '\x1E',
            '\x2', '\x222', '\x225', '\x5', '@',
            '!', '\x2', '\x223', '\x225', '\x5',
            '\x42', '\"', '\x2', '\x224', '\x221',
            '\x3', '\x2', '\x2', '\x2', '\x224',
            '\x222', '\x3', '\x2', '\x2', '\x2',
            '\x224', '\x223', '\x3', '\x2', '\x2',
            '\x2', '\x225', '\x226', '\x3', '\x2',
            '\x2', '\x2', '\x226', '\x224', '\x3',
            '\x2', '\x2', '\x2', '\x226', '\x227',
            '\x3', '\x2', '\x2', '\x2', '\x227',
            'i', '\x3', '\x2', '\x2', '\x2',
            '\x30', 'q', '~', '\x8B', '\x8D',
            '\x98', '\xAA', '\xB4', '\xC2', '\xC4',
            '\xD0', '\xD2', '\xDE', '\xE0', '\xF2',
            '\xF4', '\x100', '\x102', '\x10D', '\x118',
            '\x123', '\x12E', '\x139', '\x142', '\x149',
            '\x153', '\x157', '\x15B', '\x15D', '\x168',
            '\x16F', '\x178', '\x186', '\x18D', '\x199',
            '\x19F', '\x1A6', '\x1B0', '\x1C1', '\x1C7',
            '\x1D5', '\x1F9', '\x203', '\x209', '\x213',
            '\x224', '\x226',
        };

        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN);
    }
}