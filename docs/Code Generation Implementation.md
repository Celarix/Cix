# Code Generation Implementation

This will contradict some of what's in Code Generation. This document takes priority in those cases.

## Type Kinds

- Numeric types:
    - Signed integral types: `sbyte`, `short`, `int`, `long`
    - Unsigned integral types: `byte`, `ushort`, `uint`, `ulong`
    - Floating point types: `float`, `double`
- Structs
- Pointer types
- Function pointer types
- `void`
- Untyped

## Intrinsic Conversions

|                  | `byte` | `sbyte` | `short` | `ushort` | `int` | `uint` | `long` | `ulong` | `float` | `double` | Struct | Pointer | Function pointer |
|------------------|--------|---------|---------|----------|-------|--------|--------|---------|---------|----------|--------|---------|------------------|
| `byte`           | Yes    |         | Yes     | Yes      | Yes   | Yes    | Yes    | Yes     | Yes     | Yes      |        |         |                  |
| `sbyte`          |        | Yes     | Yes     |          | Yes   |        | Yes    |         | Yes     | Yes      |        |         |                  |
| `short`          |        |         | Yes     |          | Yes   |        | Yes    |         | Yes     | Yes      |        |         |                  |
| `ushort`         |        |         |         | Yes      | Yes   | Yes    | Yes    | Yes     | Yes     | Yes      |        |         |                  |
| `int`            |        |         |         |          | Yes   |        | Yes    |         |         | Yes      |        |         |                  |
| `uint`           |        |         |         |          |       | Yes    | Yes    | Yes     |         | Yes      |        |         |                  |
| `long`           |        |         |         |          |       |        | Yes    |         |         |          |        |         |                  |
| `ulong`          |        |         |         |          |       |        |        | Yes     |         |          |        |         |                  |
| `float`          |        |         |         |          |       |        |        |         | Yes     | Yes      |        |         |                  |
| `double`         |        |         |         |          |       |        |        |         |         | Yes      |        |         |                  |
| Struct           |        |         |         |          |       |        |        |         |         |          |        |         |                  |
| Pointer          |        |         |         |          |       |        |        |         |         |          |        | Yes     |                  |
| Function pointer |        |         |         |          |       |        |        |         |         |          |        | Yes     |                  |

## Control Flow Graph

For each function, generating code begins with converting the statement list into a *control flow graph*. The vertices of this graph are called *macroinstructions*, which represent one or more IronArc instructions, optionally with a block label above it. The edges of this graph are called *flow edges* and have types such as direct flow, unconditional jump, or jump-if-equal.

The graph is generated by walking through the statement list linearly. Macroinstructions have one or more outbound edges, depending on their type. Different outbound edges can point to the same destination. For example, an `if` macroinstruction has edges to its if-false branch and its after branch. If there is no `else` block, both edges point to the after branch.

When an expression is found, it is walked recursively to determine the types of every subexpression, the operation represented by every operator symbol, and the assignability of the subexpression.

Some additional macroinstructions are required in order to correctly manage execution, such as a macroinstruction that compares the top item on the stack to `0`.

#### Flow Edge Types

- Direct Flow: The target macroinstruction immediately follows the previous without jumps or calls.
- Unconditional Jump: The target macroinstruction is the target of a `jmp`.
- Jump if Equal: The target macroinstruction is the target of a `je`.
- Jump if Not Equal: The target macroinstruction is the target of a `jne`.
- Jump if Greater Than: The target macroinstruction is the target of a `jgt`.
- Jump if Less Than: The target macroinstruction is the target of a `jlt`.
- Jump if Greater Than or Equal To: The target macroinstruction is the target of a `jgte`.
- Jump if Less Than or Equal To: The target macroinstruction is the target of a `jlte`.

All targets of jump-typed flow edges are typically asked to generate a block label when it generates its final IronArc instructions.

#### Control Flow Graph Notation Style

Depictions of code flow graphs below are as code blocks. First, if applicable, we write the equivalent expression of what we're trying to do, then write the first macroinstruction. After the first macroinstruction, we write the flow edge with a two-letter abbreviation to show its type.

The flow edge type abbreviations are:
- `DF`: Direct flow
- `JM`: Unconditional jump
- `EQ`: Jump if equal
- `NE`: Jump if not equal
- `LT`: Jump if less than
- `GT`: Jump if greater than
- `LE`: Jump if less than or equal to
- `GE`: Jump if greater than or equal to

Macroinstructions representing IronArc instructions are written as close to the final instruction as possible. `sizeof(x)` means the size directive (`BYTE`, `WORD`, `DWORD`, or `QWORD`) that matches the size of `x`. Names in angle brackets (i.e. `<&x>`) refer to virtual stack entities. The names should clearly define what they refer to.

### The Virtual Stack

As macroinstructions are emitted, a virtual stack is kept. The virtual stack is a stack consisting of virtual stack entities (VSEs). VSEs have an offset from EBP, a name, and a size. The virtual stack begins with the arguments passed to the function. As variables are declared, they are added to the virtual stack. Intermediate values are stored on the stack but removed when no longer needed.

### Expressions

When an expression is encountered, we must compute its *result type*. This is done by querying each subexpression for its result type, and looking at the operator used on those types to determine the operation and result type. This can be done recursively on the subexpressions of subexpressions.

Once the result type and operation types are computed for all subexpressions, we then ask the expression to generate macroinstructions and give us the first and last macroinstruction for the expression evaluation. We can then link these to existing macroinstructions.

Each expression recursively asks its subexpressions to generate macroinstructions and return the first and last for its evaluation.

#### Conversion Flows

Compute `(TTarget)x`. Each graph below assumes that `x` is on top of the stack. The conversion is either widening or narrowing.

```
      mov QWORD 0 ECX
=DF=> pop sizeof(x) ECX
=DF=> push sizeof(TTarget) ECX
```

#### Array Access

Given `array[index]` where `array` is a pointer or function pointer of type `TArray*`:

First, `index` must be implicitly convertible to `int`. The following macroinstructions are generated:

```
*((ulong)array + (index * sizeof(TArray)))

      <macroinstructions to compute array>  [array]
=DF=> <macroinstructions to compute index>  [array index]
=DF=> <convert index to DWORD>              [array index]
=DF=> push DWORD sizeof(TArray)             [array index sizeof(TArray)]
=DF=> mult DWORD                            [array offsetOfIndex]
=DF=> <convert offsetOfIndex to QWORD>      [array offsetOfIndex]
=DF=> add QWORD                             [&array[index]]
=DF=> mov QWORD 0 EAX                       [&array[index]]
=DF=> pop QWORD EAX                         []
=DF=> push sizeof(TArray) *eax              [array[index]]
```

The result type is `TArray` and is not assignable.

#### BinaryExpression

Given `a OP b` where `a` is of type `TLeft` and `b` is of type `TRight`:

The valid types for `TLeft` and `TRight` are determined by the operator symbol between them and the type of `TLeft`. Note that if no implicit conversion exists between `TLeft` and `TRight`, we can try to find an implicit conversion between `TRight` and `TLeft`. Here's the operator table:

| Operator symbol | `TLeft`                                     | `TRight` must be                                | Resulting operation                                                                       | Result type              |
|-----------------|---------------------------------------------|-------------------------------------------------|-------------------------------------------------------------------------------------------|--------------------------|
| `+`             | Any numeric type                            | Implicitly convertible to `TLeft` or vice versa | Integer Addition or Floating Point Addition, depending on the result type                 | Determined implicit type |
| `+`             | Any pointer type                            | Implicitly convertible to `int`                 | Pointer Addition                                                                          | `TLeft`                  |
| `-`             | Any numeric type                            | Implicitly convertible to `TLeft` or vice versa | Integer Subtraction or Floating Point Subtraction, depending on the result type           | Determined implicit type |
| `-`             | Any pointer type                            | Implicitly convertible to `int`                 | Pointer Subtraction                                                                       | `TLeft`                  |
| `*`             | Any numeric type                            | Implicitly convertible to `TLeft` or vice versa | Integer Multiplication or Floating Point Multiplication, depending on the result type     | Determined implicit type |
| `/`             | Any numeric type                            | Implicitly convertible to `TLeft` or vice versa | Integer Division or Floating Point Division, depending on the result type                 | Determined implicit type |
| `%`             | Any numeric type                            | Implicitly convertible to `TLeft` or vice versa | Integer Modulus Division or Floating Point Modulus Division, depending on the result type | Determined implicit type |
| `&`             | Any integral type                           | Implicitly convertible to `TLeft` or vice versa | Integer Bitwise AND                                                                       | Determined implicit type |
| `\|`            | Any integral type                           | Implicitly convertible to `TLeft` or vice versa | Integer Bitwise OR                                                                        | Determined implicit type |
| `^`             | Any integral type                           | Implicitly convertible to `TLeft` or vice versa | Integer Bitwise XOR                                                                       | Determined implicit type |
| `<<`            | Any integral type                           | Implicitly convertible to `int`                 | Integer Shift Left                                                                        | `TLeft`                  |
| `>>`            | Any integral type                           | Implicitly convertible to `int`                 | Integer Shift Right                                                                       | `TLeft`                  |
| `==`            | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Equal                                                                             | `int`                    |
| `!=`            | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Not Equal                                                                         | `int`                    |
| `<`             | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Less Than                                                                         | `int`                    |
| `>`             | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Greater Than                                                                      | `int`                    |
| `<=`            | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Less Than or Equal To                                                             | `int`                    |
| `>=`            | Any type except struct                      | Implicitly convertible to `TLeft` or vice versa | Compare Greater Than or Equal To                                                          | `int`                    |
| `&&`            | Any integral type                           | Implicitly convertible to `TLeft` or vice versa | Logical AND                                                                               | `int`                    |
| `\|\|`          | Any integral type                           | Implicitly convertible to `TLeft` or vice versa | Logical OR                                                                                | `int`                    |
| `.`             | Any struct type                             | Untyped literal                                 | Direct Member Access                                                                      | Type of accessed member  |
| `->`            | Pointer whose underlying type is any struct | Untyped literal                                 | Pointer Member Access                                                                     | Type of accessed member  |
| `=`             | An assignable value of any type             | Implicitly convertible to `TLeft`               | Assignment                                                                                | `TLeft`                  |
| `+=`            | An assignable value of any numeric type     | Implicitly convertible to `TLeft`               | Integer Addition Assignment or Floating Point Addition Assignment                         | `TLeft`                  |
| `-=`            | An assignable value of any numeric type     | Implicitly convertible to `TLeft`               | Integer Subtraction Assignment or Floating Point Subtraction Assignment                   | `TLeft`                  |
| `*=`            | An assignable value of any numeric type     | Implicitly convertible to `TLeft`               | Integer Multiplication Assignment or Floating Point Multiplication Assignment             | `TLeft`                  |
| `/=`            | An assignable value of any numeric type     | Implicitly convertible to `TLeft`               | Integer Division Assignment or Floating Point Division Assignment                         | `TLeft`                  |
| `%=`            | An assignable value of any numeric type     | Implicitly convertible to `TLeft`               | Integer Modulus Division Assignment or Floating Point Modulus Division Assignment         | `TLeft`                  |
| `<<=`           | An assignable value of any integral type    | Implicitly convertible to `int`                 | Integer Shift Left Assignment                                                             | `TLeft`                  |
| `>>=`           | An assignable value of any integral type    | Implicitly convertible to `int`                 | Integer Shift Right Assignment                                                            | `TLeft`                  |
| `&=`            | An assignable value of any integral type    | Implicitly convertible to `TLeft`               | Integer Bitwise AND Assignment                                                            | `TLeft`                  |
| `\|=`           | An assignable value of any integral type    | Implicitly convertible to `TLeft`               | Integer Bitwise OR Assignment                                                             | `TLeft`                  |
| `^=`            | An assignable value of any integral type    | Implicitly convertible to `TLeft`               | Integer Bitwise XOR Assignment                                                            | `TLeft`                  |

Each operation produces different macroinstructions. Each macroinstruction sequence starts with:

```
      <macroinstructions to compute a>
=DF=> <macroinstructions to compute b>
```

##### Integer Addition

```
=DF=> <convert a or b to computed result type size>
=DF=> add sizeof(result type)
```

##### Floating Point Addition

```
=DF=> <convert a or b to computed result type size>
=DF=> fadd sizeof(result type)
```

##### Pointer Addition

```
(ulong)a + ((ulong)sizeof(TLeft) * b);

=DF=> <convert b to DWORD>          [a b]
=DF=> push DWORD sizeof(TLeft)      [a b sizeof(TLeft)]
=DF=> mult DWORD                    [a bytesAfterA]
=DF=> <convert bytesAfterA to QWORD>
=DF=> add QWORD
```

##### Integer Subtraction

```
=DF=> <convert a or b to computed result type size>
=DF=> sub sizeof(result type)
```

##### Floating Point Subtraction

```
=DF=> <convert a or b to computed result type size>
=DF=> fsub sizeof(result type)
```

##### Pointer Subtraction

```
(ulong)a - ((ulong)sizeof(TLeft) * b);

=DF=> <convert b to DWORD>          [a b]
=DF=> push DWORD sizeof(TLeft)      [a b sizeof(TLeft)]
=DF=> mult DWORD                    [a bytesBeforeA]
=DF=> <convert bytesBeforeA to QWORD>
=DF=> sub QWORD
```

##### Integer Multiplication

```
=DF=> <convert a or b to computed result type size>
=DF=> mult sizeof(result type)
```

##### Floating Point Multiplication

```
=DF=> <convert a or b to computed result type size>
=DF=> fmult sizeof(result type)
```

##### Integer Division
```
=DF=> <convert a or b to computed result type size>
=DF=> div sizeof(result type)
```

##### Floating Point Division

```
=DF=> <convert a or b to computed result type size>
=DF=> fdiv sizeof(result type)
```

##### Integer Modulus Division
```
=DF=> <convert a or b to computed result type size>
=DF=> mod sizeof(result type)
```

##### Floating Point Modulus Division

```
=DF=> <convert a or b to computed result type size>
=DF=> fmod sizeof(result type)
```

##### Integer Bitwise AND

```
=DF=> <convert a or b to computed result type size>
=DF=> bwand sizeof(result type)
```

##### Integer Bitwise OR

```
=DF=> <convert a or b to computed result type size>
=DF=> bwor sizeof(result type)
```

##### Integer Bitwise XOR

```
=DF=> <convert a or b to computed result type size>
=DF=> bwxor sizeof(result type)
```

##### Integer Shift Left

```
=DF=> <convert B to DWORD>
=DF=> lshift sizeof(result type)
```

##### Integer Shift Right

```
=DF=> <convert B to DWORD>
=DF=> rshift sizeof(result type)
```

##### Compare Equal

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x4000000000000000                 [EFLAGS equalMask]
=DF=> bwand QWORD                                   [aEqualsBFlag]
=DF=> push QWORD 62                                 [aEqualsBFlag offsetOfEqualFlag]
=DF=> rshift QWORD                                  [aEqualsB]
=DF=> (convert aEqualsB to DWORD)
```

##### Compare Not Equal

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x2000000000000000                 [EFLAGS notEqualMask]
=DF=> bwand QWORD                                   [aDoesNotEqualBFlag]
=DF=> push QWORD 61                                 [aDoesNotEqualBFlag offsetOfNotEqualFlag]
=DF=> rshift QWORD                                  [aDoesNotEqualB]
=DF=> (convert aDoesNotEqualB to DWORD)
```

##### Compare Less Than

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x1000000000000000                 [EFLAGS lessThanMask]
=DF=> bwand QWORD                                   [aLessThanBFlag]
=DF=> push QWORD 60                                 [aLessThanBFlag offsetOfLessThanFlag]
=DF=> rshift QWORD                                  [aLessThanB]
=DF=> (convert aLessThanB to DWORD)
```

##### Compare Greater Than

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x0800000000000000                 [EFLAGS greaterThanMask]
=DF=> bwand QWORD                                   [aGreaterThanBFlag]
=DF=> push QWORD 59                                 [aGreaterThanBFlag offsetOfGreaterThanFlag]
=DF=> rshift QWORD                                  [aGreaterThanB]
=DF=> (convert aGreaterThanB to DWORD)
```

##### Compare Less Than or Equal To

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x0400000000000000                 [EFLAGS lessThanOrEqualToMask]
=DF=> bwand QWORD                                   [aLessThanOrEqualToFlag]
=DF=> push QWORD 58                                 [aLessThanOrEqualToFlag offsetOfLessThanOrEqualToFlag]
=DF=> rshift QWORD                                  [aLessThanOrEqualTo]
=DF=> (convert aLessThanOrEqualTo to DWORD)
```

##### Compare Greater Than or Equal To

```
=DF=> <convert a or b to computed result type size> [a b]
=DF=> cmp sizeof(result type)                       []
=DF=> push QWORD EFLAGS                             [EFLAGS]
=DF=> push QWORD 0x0200000000000000                 [EFLAGS greaterThanOrEqualToMask]
=DF=> bwand QWORD                                   [aGreaterThanOrEqualToBFlag]
=DF=> push QWORD 57                                 [aGreaterThanOrEqualToBFlag offsetOfGreaterThanOrEqualToFlag]
=DF=> rshift QWORD                                  [aGreaterThanOrEqualToB]
=DF=> (convert aGreaterThanB to DWORD)
```

##### Logical AND

```
=DF=> <convert a or b to computed result type size>
=DF=> land sizeof(result type)
```

##### Logical OR

```
=DF=> <convert a or b to computed result type size>
=DF=> lor sizeof(result type)
```

##### Logical XOR

```
=DF=> <convert a or b to computed result type size>
=DF=> lxor sizeof(result type)
```

##### Direct Member Access

The left-hand side must be a struct type `TStruct`. The right-hand side must be an identifier that names a member of the struct.

The macroinstructions are done in two stages: get the address of the member in the struct, and copy the struct to the top of the stack. For the first stage:

If the left-hand side is a function argument or local variable:

```
*(offsetOfAFromEBP + offsetOfB)

=DF=> push QWORD EBP
=DF=> push QWORD offsetOfAFromEBP
=DF=> add QWORD
=DF=> push QWORD offsetOfB
=DF=> add QWORD
=DF=> pop QWORD EAX
```

If the left-hand side is a global variable:

```
*(&globalVariable + offsetOfB)

=DF=> push QWORD ERP
=DF=> push QWORD headerSize
=DF=> push QWORD offsetOfB
=DF=> add QWORD
=DF=> add QWORD
```

If the left-hand side is an evaluated expression resulting in `TStruct` (in which case the entire struct is on the stack):

```
=DF=> push QWORD EBP
=DF=> push QWORD offsetOfStructOnStack
=DF=> push QWORD offsetOfB
=DF=> add QWORD
=DF=> add QWORD
```

For the second stage:

If the result type is not a struct:

```
=DF=> mov QWORD 0 EAX
=DF=> mov sizeof(a.b) *addressOfADotB EAX
=DF=> subl QWORD ESP 8 ESP
=DF=> push sizeof(a.b) EAX
```

If the result type is a struct:

```
=DF=> mov QWORD 0 EAX
=DF=> pop QWORD EAX
=DF=> movln *EAX *ESP sizeof(a.b)
=DF=> mov QWORD ESP EAX
=DF=> addl QWORD EAX sizeof(a.b) EAX
=DF=> mov QWORD EAX ESP
```

##### Pointer Member Access

The left-hand side must be a pointer type whose underlying type is `TStruct`. The right-hand side must be an identifier which names a member in the struct. This expression is very similar to the direct member access, except the pointer is precalculated.

If the type of `a.b` is not a struct:

```
*(a + offsetOfB)
      push QWORD offsetOfAFromEBP
=DF=> push QWORD offsetOfB
=DF=> add QWORD
=DF=> pop QWORD EAX
=DF=> push sizeof(a.b) *EAX
```

If the type of `a.b` is a struct:

```
*(a + offsetOfB)
=DF=> push QWORD offsetOfAFromEBP
=DF=> push QWORD offsetOfB
=DF=> add QWORD
=DF=> pop QWORD EAX
=DF=> movln *EAX *ESP sizeof(a.b)
=DF=> mov QWORD ESP EAX
=DF=> addl QWORD EAX sizeof(a.b) EAX
=DF=> mov QWORD EAX ESP
```

##### Assignment

`a` must be an assignable value of type `TLeft`. `b` must be of a type implicitly convertible to `TLeft`. The expression intermediate for `a` notes that it is to be used as an assignable value, and therefore has its pointer and not its value stored on the stack.

```
=DF=> push QWORD EBP
=DF=> push QWORD offsetOfA
=DF=> add QWORD
=DF=> pop QWORD EAX
=DF=> mov sizeof(b) <b> *EAX
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(b) EAX
=DF=> subl QWORD ESP 8 ESP
=DF=> push sizeof(b) EAX
```

##### Operation Assignment

The various other assignment operators have pushed both the address of `a` and the value of `a` and then treat the expression overall as `a = a OP b`, except that `a`'s value is only evaluated once. The entire expression looks like:

```
      <macroinstructions to compute &a>          [&a]
=DF=> <macroinstructions to compute a>           [&a a]
=DF=> <macroinstructions to compute b>           [&a a b]
=DF=> <macroinstructions to compute a OP b>      [&a aOpB]
=DF=> mov QWORD <&a> EAX                         [&a aOpB]
=DF=> mov QWORD <aOpB> *EAX                      [&a aOpB]
=DF=> mov QWORD EAX 0                            [&a aOpB]
=DF=> pop sizeof(aOpB) EAX                       [&a]
=DF=> subl QWORD ESP 8 ESP                       []
=DF=> push sizeof(aOpB) EAX                      [aOpB]
```

##### Integer Shift-Left/Shift-Right Assignment

`a` must be an assignable value of type `TLeft`. `b` must be of a type implicitly convertible to `int`. The expression intermediate for `a` notes that it is to be used as an assignable value, and therefore has its pointer and not its value stored on the stack.

```
=DF=> mov QWORD <a> EAX
=DF=> lshiftl/rshiftl sizeof(a) *EAX <b>
=DF=> subl QWORD ESP sizeof(b)+8 ESP
=DF=> push sizeof(a) *EAX
```

#### Cast Expression

Casts only emit macroinstructions when they change the width of the object being cast. Otherwise, it changes the result types of parent expression intermediates, which changes the emitted macroinstructions, but otherwise does not generate macroinstructions.

#### Floating Point Literal

```
      push float/double(<the literal>)
```

#### Function Invocation

Given `a(b, c, d)`, `a` must either be an identifier naming a function, or an expression with a function pointer type. Each argument must be of the same type of the function or function pointer's argument at the same position, and must have the same number of arguments.

```
      <macroinstructions to compute a>
=DF=> stackargs
=DF=> <macroinstructions to evaluate b>
=DF=> <macroinstructions to evaluate c>
=DF=> <macroinstructions to evaluate d>
=DF=> call <a>
```

#### Hardware Call Returns Internal

This expression intermediate is internal to the compiler and is the only expression within a generated function for the hardware call.


```
      hwcall <name of hardware call>
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(hardware call result) EAX
=DF=> push sizeof(hardware call result) EAX
```

#### Hardware Call Void Internal
```
      hwcall <name of hardware call>
```

#### Identifier

This expression intermediate names either a local variable, function argument, global variable, or function. It is marked as either assignable or value, and can have either its address or value evaluated.

##### Local Variable or Function Argument's Value

```
      mov QWORD 0 EAX
=DF=> mov sizeof(variable) <variable> EAX
=DF=> push sizeof(variable) EAX
```

##### Local Variable or Function Argument's Address

```
      push QWORD EBP
=DF=> push QWORD <offset of variable from EBP>
=DF=> add QWORD
```

##### Global Variable's Value

```
      mov QWORD 0 EAX
=DF=> push QWORD ERP
=DF=> push QWORD <header size + offset of global>
=DF=> add QWORD
=DF=> pop QWORD EAX
=DF=> push sizeof(global) *EAX
```

##### Global Variable's Address

```
      push QWORD ERP
=DF=> push QWORD <header size + global offset>
=DF=> add QWORD
```

##### Function

```
      push <function name>
```

#### Integer Literal

```
      push sizeof(literal) <literal>
```

#### Size Of Expression

```
      push QWORD <size of type>
```

#### String Literal

```
      push <string literal>
```

#### Ternary Expression

There's only one ternary expression, the `? :` conditional operator. Given `a ? b : c`, `a` must be a type implicitly convertible to `int`, and `b` and `c` must be of types implicitly convertible to each other.

```
      <macroinstructions to compute a>
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(a) EAX
=DF=> push DWORD EAX
=DF=> push DWORD 0
=DF=> cmp DWORD
=NE=> <macroinstructions to compute b> =EQ=> <macroinstructions to compute c>
=JM=> (code after ternary)
```

#### Unary Expressions

##### Identity

Given `+x`, `x` must be any numeric type.

```
      <macroinstructions to compute x>
```

##### Integer Inverse

Given `-x`, `x` must be any integral type.

```
0 - x

      <macroinstructions to compute x>
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(x) EAX
=DF=> push sizeof(x) 0
=DF=> push sizeof(x) EAX
=DF=> sub sizeof(x)
```

##### Bitwise NOT

Given `~x`, `x` must be any integral type.

```
      <macroinstructions to compute x>
=DF=> bwnot sizeof(x)
```

##### Logical NOT

Given `!x`, `x` must be any integral type.

```
      <macroinstructions to compute x>
=DF=> lnot sizeof(x)
```

##### Integral Pre-Increment and Pre-Decrement

Given `++x` or `--x`, which first changes the value and then returns the changed value, `x` must be any assignable integer type. `x` must be treated as assignable, and therefore we must get the pointer of the value, not the value itself.

```
      <macroinstructions to compute x>  [x]
      <macroinstructions to compute &x> [x &x]
=DF=> incl/decl sizeof(x) <&x>          [x &x]
=DF=> subl QWORD ESP 8 ESP              [x]
=DF=> inc/dec sizeof(x)                 [++x/--x]
```

##### Integral Post-Increment and Post-Decrement

Given `++x` or `--x`, which first returns the value and then changes the value, `x` must be any assignable integer type.

```
      <macroinstructions to compute x>  [x]
=DF=> <macroinstructions to compute &x> [x &x]
=DF=> incl/decl sizeof(x) <&x>          [x &x]
=DF=> subl QWORD ESP 8 ESP              [x]
```

##### Floating Point Pre-Increment and Pre-Decrement

Given `++x` or `--x`, `x` must be any assignable floating point type.

```
      <macroinstructions to compute x>  [x]
      <macroinstructions to compute &x> [x &x]
=DF=> push sizeof(x) <x>                [x &x x]
=DF=> push float/double(1)              [x &x x 1]
=DF=> fadd/fsub sizeof(x)               [x &x ++x/--x]
=DF=> pop sizeof(x) *<&x>               [x &x]
=DF=> subl QWORD ESP 8 ESP              [x]
=DF=> push float/double(1)              [x 1]
=DF=> fadd/fsub sizeof(x)               [++x/--x]
```

##### Floating Point Post-Increment and Post-Decrement

Given `x++` or `x--`, `x` must be any assignable floating point type.

```
      <macroinstructions to compute x>  [x]
=DF=> <macroinstructions to compute &x> [x &x]
=DF=> push sizeof(x) <x>                [x &x x]
=DF=> push float/double(1)              [x &x x 1]
=DF=> fadd/fsub sizeof(x)               [x &x ++x/--x]
=DF=> pop sizeof(x) *<&x>               [x &x]
=DF=> subl QWORD ESP 8 ESP              [x]
```

##### Address Of

Given `&x`, `x` must be any assignable value of type `T`. The result is of type `T*`, unless `x` is a function, in which case the result is a function pointer type.

Local variables and function arguments:

```
      push QWORD EBP
=DF=> push QWORD <offset of x from EBP>
=DF=> add QWORD
```

Global variables:

```
      push QWORD ERP
=DF=> push QWORD <header size + global offset>
=DF=> add QWORD
```

Functions:

```
    push <function name>
```

##### Value At

Given `*x`, `x` must a pointer of type `T*` which is not a function pointer. The result is of type `T`.

Primitive types:

```
      pop QWORD EAX
=DF=> push sizeof(*x) *EAX
```

Structs:
```
      pop QWORD EAX
=DF=> movln *EAX *ESP sizeof(x)
```

### Statements

#### Block

A block is a self-contained list of statements. Blocks are often the children of `if`, `while`, `do-while`, etc. Blocks are flowed directly into and directly out of. Variables declared in a block are removed from scope when the block ends.

#### Break Statement

Break statements may appear in case statements, while loops, and do-while loops. It skips to outside the switch block that the case block belongs to, or to after the loop it's in.

```
=JM=> <macroinstruction after switch/loop>
```

#### Case Statement

Case statements are jumped to by the switch block's evaluation of the expression and are flowed directly out of when the statement inside the case statement is executed.

#### Conditional Statement

```
if (x) { statement; } after;
      <macroinstructions to compute x>
=DF=> <convert x to DWORD>
=DF=> push DWORD 0
=DF=> cmp DWORD
=NE=> (statement) =JM======+
=EQ=> (after)   <==========+

if (x) { true; } else { false; } after;

      <macroinstructions to compute x>
=DF=> <convert x to DWORD>
=DF=> push DWORD 0
=DF=> cmp DWORD
=NE=> (statement) =EQ=> (else)
           |              |
          JM             JM
           v              |
      (after) <===========+
```

#### Continue Statement

Continue statements may appear in loops and jump back to the condition evaluation.

#### Do While Loop

```
do { statement; } while (x); after;

      (statement)   <====================+
=JM=> <macroinstructions to evaluate x>  |
=DF=> <convert x to DWORD>               |
=DF=> push DWORD 0                       |
=DF=> cmp DWORD                          |
=====+======================NE===========+
     |
     EQ=> (after)
```

#### Expression Statement

```
x;

      <macroinstructions to compute x>
=DF=> subl QWORD ESP sizeof(x) ESP
```

#### For Statement

All for loops were rewritten to while loops in the lowering phase and, thus, do not exist here.

#### Return Statement

```
return;
      ret

return x; // assuming x is a primitive type
      <macroinstructions to compute x>
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(x) EAX
=DF=> mov QWORD EBP ESP
=DF=> push sizeof(x) EAX
=DF=> ret

return x; // assuming x is a struct
      movln *EBP *<x> sizeof(x)
=DF=> mov QWORD EBP ESP
=DF=> ret
```

#### Switch and Case Statements

```
switch(x)
{
    case 0: statement;
    case 1: statement;
    default: statement
}

      <macroinstructions to compute x> 
=DF=> mov QWORD 0 EAX
=DF=> pop sizeof(x) EAX
=DF=> cmpl sizeof(x) EAX (first case literal) EBX
=DF=> push QWORD EBX
=DF=> push QWORD 0
=DF=> cmp QWORD
=EQ=> (first case statement) =NE====================+
      cmpl sizeof(x) EAX (second case literal) EBX <+
=DF=> push QWORD EBX
=DF=> push QWORD 0
=DF=> cmp QWORD
=EQ=> (second case statement) =NE====================+
      (default case statement) <=====================+
```

#### While Statement

```
while (x) { statement; } after;

      <macroinstructions to compute x> <+
=DF=> <convert x to DWORD>              |
=DF=> push DWORD 0                      |
=DF=> cmp DWORD =EQ=> (after)           |
=NE=> (statement) =DF===================+
```